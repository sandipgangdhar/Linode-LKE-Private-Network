# 04-vlan-manager-scripts-configmap.yaml
# 
# This YAML file defines the ConfigMap for VLAN Manager scripts in Linode LKE.
# It includes the following scripts for IP allocation, release, VLAN attachment,
# and IP list initialization:
# 
# 1Ô∏è‚É£ 02-script-vlan-attach.sh   - Attaches the VLAN to the Linode instance and sets up routing.
# 2Ô∏è‚É£ 03-script-ip-allocate.sh   - Allocates an IP address from the subnet.
# 3Ô∏è‚É£ 04-script-ip-release.sh    - Releases the IP address back to the pool.
# 4Ô∏è‚É£ 05-script-ip-list-initialize.sh - Initializes the IP list from the subnet.
# 5Ô∏è‚É£ 06-rest-api.py             - REST API to manage IP allocation and release.
# 
# -----------------------------------------------------
# üìù Parameters:
# 
# 1Ô∏è‚É£ SUBNET            - Subnet for IP allocation.
# 2Ô∏è‚É£ ROUTE_IP          - Gateway IP for the primary subnet.
# 3Ô∏è‚É£ VLAN_LABEL        - VLAN identifier for Linode.
# 4Ô∏è‚É£ DEST_SUBNET       - Destination subnet for routing.
# 5Ô∏è‚É£ API_ENDPOINT      - URL for IP allocation and release.
# 
# -----------------------------------------------------
# üîÑ Usage:
# 
# - These scripts are mounted into the VLAN Manager Pod and executed during
#   VLAN attachment, IP allocation, and IP release processes.
# - Communication is handled through the configured API endpoints.
# 
# -----------------------------------------------------
# üìå Best Practices:
# 
# - Ensure the VLAN label and subnet are correctly configured before running.
# - Monitor logs for connectivity issues during VLAN attachment.
# - Use health checks to validate API availability before IP allocation.
# 
# -----------------------------------------------------
# üñãÔ∏è Author:
# - Sandip Gangdhar
# - GitHub: https://github.com/sandipgangdhar
# 
# ¬© Linode-LKE-Private-Network | Developed by Sandip Gangdhar | 2025
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vlan-manager-scripts
  namespace: kube-system
data:
  02-script-vlan-attach.sh: |
        #!/bin/bash
        set -e
        
        # === Environment Variables ===
        # These variables are populated from Kubernetes ConfigMap or environment
        SUBNET="${SUBNET}"
        export ROUTE_LIST="${ROUTE_LIST:-}"
        VLAN_LABEL="${VLAN_LABEL}"
        DEST_SUBNET="${DEST_SUBNET}"
        
        ENABLE_PUSH_ROUTE="$(echo "$ENABLE_PUSH_ROUTE" | tr '[:upper:]' '[:lower:]')"   # control route pushing
        ENABLE_FIREWALL="$(echo "$ENABLE_FIREWALL" | tr '[:upper:]' '[:lower:]')"       # control Linode Firewall
        LKE_CLUSTER_ID="${LKE_CLUSTER_ID}"
        
        # === New VPC + VLAN-EW firewall config ===
        ENABLE_VPC_INTERFACE="$(echo "${ENABLE_VPC_INTERFACE:-false}" | tr '[:upper:]' '[:lower:]')"
        VPC_SUBNET_ID="${VPC_SUBNET_ID:-}"                     # numeric Linode VPC subnet_id
        VPC_INTERFACE_INDEX="${VPC_INTERFACE_INDEX:-2}"        # interface index for eth2
        
        ENABLE_VLAN_EW_FIREWALL="$(echo "${ENABLE_VLAN_EW_FIREWALL:-false}" | tr '[:upper:]' '[:lower:]')"
        VLAN_INTERFACE_NAME="${VLAN_INTERFACE_NAME:-eth1}"     # override if needed, default eth1
        
        # === Function to Log Events ===
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        log "üîÑ Starting VLAN + VPC Attachment Script..."
        
        # Wait for DNS to resolve
        function wait_for_dns() {
            while ! nslookup api.linode.com >/dev/null 2>&1; do
                log "üåê DNS resolution failed. Retrying in 10 seconds..."
                sleep 10
            done
            log "‚úÖ DNS resolution successful."
        }
        
        # üßº Cleanup old CoreDNS reboot lock if held by this node
        REBOOT_LOCK_KEY="/coredns-reboot-lock"
        CURRENT_NODE=$(hostname)
        if [ -n "$ETCD_ENDPOINTS" ]; then
            # Wait for etcd DNS to resolve
            until nslookup etcd-0.etcd.kube-system.svc.cluster.local >/dev/null 2>&1; do
                log "üåê Waiting for DNS to resolve etcd-0 during lock cleanup..."
                sleep 5
            done
        
            # Check and delete the lock if this node owns it
            LOCK_OWNER=$(etcdctl --endpoints "$ETCD_ENDPOINTS" get "$REBOOT_LOCK_KEY" --print-value-only 2>/dev/null)
            if [[ "$LOCK_OWNER" == "$CURRENT_NODE" ]]; then
                etcdctl --endpoints "$ETCD_ENDPOINTS" del "$REBOOT_LOCK_KEY"
                log "üßπ Removed stale CoreDNS reboot lock held by $CURRENT_NODE"
            fi
        fi
        
        # === Function to check if VLAN is already attached (interfaces[1]) ===
        is_vlan_attached() {
            wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
            VLAN_STATUS=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].purpose // empty')
            if [ "$VLAN_STATUS" == "vlan" ]; then
                return 0
            else
                return 1
            fi
        }
        
        # === Function to check if VPC is already attached (interfaces[VPC_INTERFACE_INDEX]) ===
        is_vpc_attached() {
            # Do NOT depend on ENABLE_VPC_INTERFACE here; just read actual config
            wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
        
            local idx="${VPC_INTERFACE_INDEX:-2}"
            local PURPOSE
        
            PURPOSE=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json \
                | jq -r ".[0].interfaces[$idx].purpose // empty")
        
            if [[ "$PURPOSE" == "vpc" ]]; then
                return 0
            else
                return 1
            fi
        }
        
        # === Serialized reboot logic (CoreDNS-aware) ===
        serialized_reboot() {
            REBOOT_LOCK_KEY="/coredns-reboot-lock"
            CURRENT_NODE=$(hostname)
            export ETCDCTL_API=3
        
            if [ -z "$ETCD_ENDPOINTS" ]; then
                log "‚ùå ETCD_ENDPOINTS not set. Aborting reboot!"
                sleep infinity
            fi
        
            log "üîç Checking if this node is hosting a CoreDNS pod..."
            set +e
            COREDNS_HOST=$(kubectl get pods -n kube-system -o json | jq -r \
                '.items[] | select(.metadata.labels["k8s-app"] == "kube-dns") | .spec.nodeName' \
                | grep -w "$CURRENT_NODE")
            KUBE_EXIT=$?
            set -e
        
            if [[ "$KUBE_EXIT" -ne 0 ]]; then
                log "‚ö†Ô∏è Failed to fetch CoreDNS pod status. Assuming no CoreDNS on this node. Proceeding with immediate reboot."
            fi
        
            if [[ -n "$COREDNS_HOST" ]]; then
                log "üß† $CURRENT_NODE is hosting a CoreDNS pod. Serialized reboot enabled."
        
                ACQUIRED=false
                while [[ "$ACQUIRED" != true ]]; do
                    until nslookup etcd-0.etcd.kube-system.svc.cluster.local >/dev/null 2>&1; do
                        log "üåê Waiting for DNS to resolve etcd-0..."
                        sleep 5
                    done
        
                    log "üîí Attempting atomic lock via etcd transaction..."
        
                    BASE64_KEY=$(echo -n "$REBOOT_LOCK_KEY" | base64)
                    BASE64_NODE=$(echo -n "$CURRENT_NODE" | base64)
        
                    TXN_PAYLOAD=$(cat <<EOF
        {
          "compare": [
            {
              "key": "$BASE64_KEY",
              "target": "VERSION",
              "result": "EQUAL",
              "version": "0"
            }
          ],
          "success": [
            {
              "requestPut": {
                "key": "$BASE64_KEY",
                "value": "$BASE64_NODE"
              }
            }
          ],
          "failure": [
            {
              "requestRange": {
                "key": "$BASE64_KEY"
              }
            }
          ]
        }
        EOF
        )
        
                    RESPONSE=$(curl -s -X POST "http://etcd-0.etcd.kube-system.svc.cluster.local:2379/v3/kv/txn" \
                      -H "Content-Type: application/json" \
                      -d "$TXN_PAYLOAD")
        
                    if echo "$RESPONSE" | grep -q '"succeeded":true'; then
                        log "‚úÖ Lock acquired by $CURRENT_NODE for CoreDNS reboot."
                        ACQUIRED=true
                    else
                        HOLDER=$(echo "$RESPONSE" | jq -r '.responses[0].response_range.kvs[0].value' | base64 -d)
                        log "‚õî Lock held by $HOLDER. Waiting 10s before retry..."
                        sleep 10
                    fi
                done
            else
                log "üöÄ This node is NOT hosting a CoreDNS pod. Rebooting immediately..."
            fi
        
            # === Reboot logic ===
            log "üîÅ Initiating reboot via Linode CLI..."
            RETRY=0
            MAX_RETRIES=10
        
            while true; do
                set +e
                wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
                linode-cli linodes reboot "$LINODE_ID"
                EXIT_CODE=$?
                set -e
        
                if [[ "$EXIT_CODE" -eq 0 ]]; then
                    log "‚úÖ Reboot command succeeded."
                    break
                else
                    log "‚ö†Ô∏è Reboot failed (possibly Linode busy). Retrying in 5s... ($((RETRY+1))/$MAX_RETRIES)"
                    RETRY=$((RETRY + 1))
                    if [[ $RETRY -ge $MAX_RETRIES ]]; then
                        log "‚ùå Reboot failed after $MAX_RETRIES attempts. Sleeping indefinitely."
                        sleep infinity
                    fi
                    sleep 5
                fi
            done
        }
        
        # === Function: Detect Configured-But-Missing VLAN Interface and Trigger Reboot ===
        function handle_vlan_configured_but_missing_interface() {
            set +e
            wait_for_dns
            VLAN_ATTACHED=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].purpose // empty')
            set -e
        
            if [[ "$VLAN_ATTACHED" == "vlan" ]]; then
                set +e
                wait_for_dns
                VLAN_IP=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].ipam_address // empty')
                set -e
                wait_for_dns
                VLAN_INTERFACE=$(ip -o addr show | grep "$VLAN_IP" | awk '{print $2}' | head -n1)
        
                if [[ -z "$VLAN_INTERFACE" ]]; then
                    log "‚ö†Ô∏è VLAN is attached in config but the interface is missing. Reboot is likely pending from previous run."
        
                    CURRENT_NODE=$(hostname)
                    REBOOT_LOCK_KEY="/coredns-reboot-lock"
                    ETCD_URL="http://etcd-0.etcd.kube-system.svc.cluster.local:2379"
        
                    log "üîç Checking if this node is hosting a CoreDNS pod..."
                    set +e
                    COREDNS_HOST=$(kubectl get pods -n kube-system -o json | jq -r \
                        '.items[] | select(.metadata.labels["k8s-app"] == "kube-dns") | .spec.nodeName' \
                        | grep -w "$CURRENT_NODE")
                    KUBE_EXIT=$?
                    set -e
        
                    if [[ "$KUBE_EXIT" -ne 0 || -z "$COREDNS_HOST" ]]; then
                        log "üöÄ This node is NOT hosting a CoreDNS pod. Rebooting immediately..."
                    else
                        log "üß† $CURRENT_NODE is hosting a CoreDNS pod. Serialized reboot enabled."
        
                        ACQUIRED=false
                        while [[ "$ACQUIRED" != true ]]; do
                            until nslookup etcd-0.etcd.kube-system.svc.cluster.local >/dev/null 2>&1; do
                                log "üåê Waiting for DNS to resolve etcd-0..."
                                sleep 5
                            done
        
                            log "üîí Attempting atomic lock via etcd transaction..."
        
                            TXN_PAYLOAD=$(cat <<EOF
        {
          "compare": [
            {
              "key": "$(echo -n "$REBOOT_LOCK_KEY" | base64)",
              "target": "VERSION",
              "result": "EQUAL",
              "version": "0"
            }
          ],
          "success": [
            {
              "requestPut": {
                "key": "$(echo -n "$REBOOT_LOCK_KEY" | base64)",
                "value": "$(echo -n "$CURRENT_NODE" | base64)"
              }
            }
          ],
          "failure": [
            {
              "requestRange": {
                "key": "$(echo -n "$REBOOT_LOCK_KEY" | base64)"
              }
            }
          ]
        }
        EOF
        )
        
                            RESPONSE=$(curl -s -X POST "$ETCD_URL/v3/kv/txn" \
                                -H "Content-Type: application/json" \
                                -d "$TXN_PAYLOAD")
        
                            if echo "$RESPONSE" | grep -q '"succeeded":true'; then
                                log "‚úÖ Lock acquired by $CURRENT_NODE for CoreDNS reboot."
                                ACQUIRED=true
                            else
                                HOLDER=$(echo "$RESPONSE" | jq -r '.responses[0].response_range.kvs[0].value' | base64 -d)
                                log "‚õî Lock held by $HOLDER. Waiting 10s before retry..."
                                sleep 10
                            fi
                        done
                    fi
        
                    # === Reboot logic ===
                    log "üîÅ Initiating reboot via Linode CLI to apply VLAN changes..."
                    RETRY=0
                    MAX_RETRIES=10
        
                    while true; do
                        set +e
                        wait_for_dns
                        linode-cli linodes reboot "$LINODE_ID"
                        EXIT_CODE=$?
                        set -e
        
                        if [[ "$EXIT_CODE" -eq 0 ]]; then
                            log "‚úÖ Reboot command succeeded."
                            break
                        else
                            log "‚ö†Ô∏è Reboot failed (possibly Linode busy). Retrying in 5s... ($((RETRY+1))/$MAX_RETRIES)"
                            RETRY=$((RETRY + 1))
                            if [[ $RETRY -ge $MAX_RETRIES ]]; then
                                log "‚ùå Reboot failed after $MAX_RETRIES attempts. Sleeping indefinitely."
                                sleep infinity
                            fi
                            sleep 5
                        fi
                    done
        
                    sleep 300
                    log "‚ö†Ô∏è Node did not reboot as expected. Sleeping to avoid loop."
                    sleep infinity
                fi
            fi
        }
        
        # === Helper: get VLAN interface name (eth1 or detected by IP) ===
        get_vlan_interface_name() {
            if [[ -n "$VLAN_INTERFACE_NAME" ]]; then
                echo "$VLAN_INTERFACE_NAME"
                return 0
            fi
        
            wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
            local VLAN_IP
            VLAN_IP=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json \
                | jq -r '.[0].interfaces[1].ipam_address // empty')
        
            if [[ -z "$VLAN_IP" ]]; then
                log "‚ùå Could not read VLAN ipam_address from config. Falling back to eth1."
                echo "eth1"
                return 0
            fi
        
            local VLAN_IP_ADDR
            VLAN_IP_ADDR=$(echo "$VLAN_IP" | cut -d'/' -f1)
        
            local IFACE
            IFACE=$(ip -o addr | awk -v ip="$VLAN_IP_ADDR" '$0 ~ ip {print $2; exit}')
        
            if [[ -z "$IFACE" ]]; then
                log "‚ö†Ô∏è Could not detect interface for VLAN IP $VLAN_IP_ADDR. Falling back to eth1."
                echo "eth1"
            else
                echo "$IFACE"
            fi
        }
        
        # === VLAN east‚Äìwest firewall rules (idempotent) ===
        configure_vlan_ew_firewall() {
            if [[ "$ENABLE_VLAN_EW_FIREWALL" != "true" ]]; then
                log "‚ÑπÔ∏è Skipping VLAN east‚Äìwest firewall; ENABLE_VLAN_EW_FIREWALL != true."
                return 0
            fi
        
            local VLAN_IF
            VLAN_IF=$(get_vlan_interface_name)
        
            log "üõ°Ô∏è Enforcing VLAN east‚Äìwest firewall on interface: $VLAN_IF"
        
            # 1. Allow responses to node-initiated connections on VLAN
            if iptables -C INPUT -i "$VLAN_IF" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT 2>/dev/null; then
                log "‚úÖ Rule already present: ACCEPT ESTABLISHED,RELATED on $VLAN_IF"
            else
                iptables -A INPUT -i "$VLAN_IF" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
                log "‚ûï Added rule: ACCEPT ESTABLISHED,RELATED on $VLAN_IF"
            fi
        
            # 2. Drop all NEW inbound on VLAN (no one should initiate to workers on VLAN)
            if iptables -C INPUT -i "$VLAN_IF" -m conntrack --ctstate NEW -j DROP 2>/dev/null; then
                log "‚úÖ Rule already present: DROP NEW on $VLAN_IF"
            else
                iptables -A INPUT -i "$VLAN_IF" -m conntrack --ctstate NEW -j DROP
                log "‚ûï Added rule: DROP NEW on $VLAN_IF"
            fi
        }
        
        # === Attach only VPC interface when VLAN is already present ===
        attach_vpc_interface_only() {
            if [[ "$ENABLE_VPC_INTERFACE" != "true" ]]; then
                log "‚ÑπÔ∏è VPC interface management disabled. Skipping VPC attach."
                return 0
            fi
        
            if [[ -z "$VPC_SUBNET_ID" ]]; then
                log "‚ùå ENABLE_VPC_INTERFACE=true but VPC_SUBNET_ID is empty. Sleeping to avoid loops."
                sleep infinity
            fi
        
            if is_vpc_attached; then
                log "‚úÖ VPC interface already attached. Skipping VPC config-update."
                return 0
            fi
        
            log "üöÄ Attaching VPC interface (subnet_id=$VPC_SUBNET_ID) at interfaces[$VPC_INTERFACE_INDEX]..."
            wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
        
            local CONFIG_JSON
            CONFIG_JSON=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq '.[0]')
        
            local UPDATED_INTERFACES
            UPDATED_INTERFACES=$(echo "$CONFIG_JSON" | jq --argjson subnet_id "$VPC_SUBNET_ID" '
                .interfaces | .['"$VPC_INTERFACE_INDEX"'] = { "purpose": "vpc", "subnet_id": $subnet_id }
            ')
        
            wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
            linode-cli linodes config-update "$LINODE_ID" "$CONFIG_ID" --interfaces "$UPDATED_INTERFACES"
        
            log "‚úÖ VPC interface successfully attached as eth${VPC_INTERFACE_INDEX}."
        }
        
        # === Function to push the route ===
        push_route() {
            if [[ "$ENABLE_PUSH_ROUTE" == "true" ]]; then
                echo "üì¶ Parsing ROUTE_LIST from ConfigMap..."
                # üåê Check if any DEST_SUBNET is 172.17.0.0/16 and delete default Docker route if needed
                log "üîç Scanning ROUTE_LIST to see if 172.17.0.0/16 is present..."
        
                if echo "$ROUTE_LIST" | grep -q 'dest_subnet: "172.17.0.0/16"'; then
                    log "‚ö†Ô∏è Found route for 172.17.0.0/16 in ROUTE_LIST. Checking and deleting LKE Docker route if exists..."
        
                    set +e
                    ip route show | grep -q "^172.17.0.0/16.*docker0"
                    DEFAULT_LKE_ROUTE_STATUS=$?
                    set -e
        
                    if [ $DEFAULT_LKE_ROUTE_STATUS -eq 0 ]; then
                        set +e
                        ip route delete 172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1
                        DELETE_STATUS=$?
                        set -e
        
                        if [ $DELETE_STATUS -eq 0 ]; then
                            log "‚úÖ Default LKE Docker Route for 172.17.0.0/16 successfully deleted"
                        else
                            log "‚ö†Ô∏è Failed to delete LKE Docker route for 172.17.0.0/16. Please verify manually."
                        fi
                    else
                        log "‚úÖ No LKE Docker route for 172.17.0.0/16 found. Nothing to delete."
                    fi
                else
                    log "‚úÖ ROUTE_LIST does not contain 172.17.0.0/16. Skipping Docker route check."
                fi
        
                echo "$ROUTE_LIST" | while read -r line; do
                    if [[ "$line" =~ route_ip ]]; then
                        ROUTE_IP=$(echo "$line" | awk -F': ' '{print $2}' | tr -d '"')
                    elif [[ "$line" =~ dest_subnet ]]; then
                        DEST_SUBNET=$(echo "$line" | awk -F': ' '{print $2}' | tr -d '"')
        
                        if [[ -z "$ROUTE_IP" || "$ROUTE_IP" == "0.0.0.0" || -z "$DEST_SUBNET" || "$DEST_SUBNET" == "0.0.0.0/0" ]]; then
                            log "‚ùå ENABLE_PUSH_ROUTE is true, but ROUTE_IP or DEST_SUBNET is unset or invalid."
                            log "üõë Skipping route push and sleeping indefinitely to avoid container crash loop."
                            sleep infinity
                        fi
                        log "üîÅ Processing Route: $DEST_SUBNET via $ROUTE_IP"
                        log "üì¶ ENABLE_PUSH_ROUTE: $ENABLE_PUSH_ROUTE"
                        log "üì¶ ROUTE_IP: $ROUTE_IP"
                        log "üì¶ DEST_SUBNET: $DEST_SUBNET"
        
                        log "Checking the VLAN_INTERFACE..."
                        # Extract the VLAN IP
                        wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
                        VLAN_IP=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].ipam_address // empty')
        
                        # Extract the IP portion (strip subnet)
                        VLAN_IP_ADDR=$(echo "$VLAN_IP" | cut -d'/' -f1)
                        log "VLAN IP is $VLAN_IP_ADDR..."
                        VLAN_INTERFACE=$(ip -o addr | awk -v ip="$VLAN_IP_ADDR" '$0 ~ ip {print $2; exit}')
                        log "üì¶ VLAN interface value is: $VLAN_INTERFACE"
        
                        if [[ -z "$VLAN_INTERFACE" ]]; then
                            log "‚ùå Could not resolve VLAN interface for IP $VLAN_IP. Sleeping indefinitely..."
                            sleep infinity
                        fi
        
                        log "üì¶ ENABLE_PUSH_ROUTE value is: $ENABLE_PUSH_ROUTE"
                        log "üì¶ ROUTE_IP value is: $ROUTE_IP"
                        log "üì¶ DEST_SUBNET value is: $DEST_SUBNET"
        
                        log "Checking if route already exists for $DEST_SUBNET..."
                        set +e
                        ip route show | grep -q "$DEST_SUBNET"
                        STATUS=$?
                        set -e
        
                        if [ $STATUS -eq 0 ]; then
                            log "‚úÖ Route $DEST_SUBNET already exists. Skipping addition."
                        else
                            log "‚öôÔ∏è  Adding route $DEST_SUBNET via $ROUTE_IP on $VLAN_INTERFACE..."
                            set +e
                            ip route add "$DEST_SUBNET" via "$ROUTE_IP" dev $VLAN_INTERFACE
                            ADD_STATUS=$?
                            set -e
        
                            if [ $ADD_STATUS -eq 0 ]; then
                                log "‚úÖ Route $DEST_SUBNET via $ROUTE_IP successfully added to $VLAN_INTERFACE."
                            else
                                log "‚ö†Ô∏è  Failed to add route $DEST_SUBNET via $ROUTE_IP. It may already exist."
                            fi
                        fi
                    fi
                done
            else
                log "‚ÑπÔ∏è Skipping route push as ENABLE_PUSH_ROUTE is set to false."
            fi
        }
        
        # === Function to create and attach firewall ===
        create_and_attach_firewall() {
            if [[ "$ENABLE_FIREWALL" != "true" ]]; then
                log "‚ÑπÔ∏è Skipping firewall creation as ENABLE_FIREWALL is set to false."
                return 0
            fi
        
            FIREWALL_LABEL="lke-cluster-firewall-${LKE_CLUSTER_ID}"
            log "üîç Checking if firewall '$FIREWALL_LABEL' already exists..."
        
            set +e
            wait_for_dns # ‚è≥ Ensure DNS is up before calling Linode API
            FIREWALL_ID=$(linode-cli firewalls list --json 2>/dev/null | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
            set -e
        
            if [[ -z "$FIREWALL_ID" ]]; then
                log "üöÄ Creating new firewall with label $FIREWALL_LABEL..."
                set +e
                wait_for_dns # ‚è≥ Ensure DNS is up before calling Linode API
                CREATE_OUTPUT=$(linode-cli firewalls create \
                  --label "$FIREWALL_LABEL" \
                  --rules.inbound='[
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "10250,10256", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Kubelet_Health_Checks"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "51820", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "kubectl_proxy_Wireguard_tunnel"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "53", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "TCP_cluster_DNS_access"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "53", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "UDP_cluster_DNS_access"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "179", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Calico_BGP_traffic"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "5473", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Calico_Typha_traffic"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "30000-32767", "addresses": { "ipv4": ["192.168.255.0/24"] }, "label": "NodeBalancer_TCP"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "30000-32767", "addresses": { "ipv4": ["192.168.255.0/24"] }, "label": "NodeBalancer_UDP"},
                    {"action": "ACCEPT", "protocol": "IPENCAP", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "NP_CP_communication"}
                  ]' \
                  --rules.outbound='[
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "1-65535", "addresses": { "ipv4": ["0.0.0.0/0"] }, "label": "Allow_All_TCP_Outbound"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "1-65535", "addresses": { "ipv4": ["0.0.0.0/0"] }, "label": "Allow_All_UDP_Outbound"}
                  ]' \
                  --rules.inbound_policy="DROP" \
                  --rules.outbound_policy="ACCEPT" \
                  --json)
                CREATE_STATUS=$?
                set -e
        
                if [[ $CREATE_STATUS -ne 0 || -z "$CREATE_OUTPUT" ]]; then
                    log "‚ö†Ô∏è Firewall creation failed, checking if it was created by another node..."
                    log "‚ö†Ô∏è First let's give 60 sec to Linode for creation...."
                    sleep 60
                    set +e
                    wait_for_dns # ‚è≥ Ensure DNS is up before calling Linode AP
                    FIREWALL_ID=$(linode-cli firewalls list --json | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
                    set -e
                    if [[ -z "$FIREWALL_ID" ]]; then
                        log "‚ùå Firewall creation failed and it does not exist. Sleeping indefinitely."
                        sleep infinity
                    else
                        log "‚úÖ Firewall was created by another process. Continuing with ID $FIREWALL_ID"
                    fi
                else
                    wait_for_dns # ‚è≥ Ensure DNS is up before calling Linode API
                    FIREWALL_ID=$(linode-cli firewalls list --json | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
                    log "‚úÖ Firewall created with ID $FIREWALL_ID"
                fi
                wait_for_dns # ‚è≥ Ensure DNS is up before calling Linode API
                FIREWALL_ID=$(linode-cli firewalls list --json | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
                log "‚úÖ Firewall created with ID $FIREWALL_ID"
            else
                log "‚úÖ Firewall $FIREWALL_LABEL already exists with ID $FIREWALL_ID"
            fi
        
            # Check if any firewall is already attached to this Linode
            log "üîç Verifying if Linode ID $LINODE_ID already has any firewall attached..."
            wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
            FIREWALLS_WITH_ENTITIES=$(linode-cli firewalls list --json | jq -r '.[] | select(.entities != null) | @base64')
            for fw in $FIREWALLS_WITH_ENTITIES; do
                _jq() { echo "$fw" | base64 --decode | jq -r "$1"; }
                FW_ID=$(_jq '.id')
                wait_for_dns # ‚è≥ Ensure DNS is up before calling Linode API
                ENTITY_IDS=$(linode-cli firewalls view "$FW_ID" --json | jq -r '.[0].entities[]?.id')
                for id in $ENTITY_IDS; do
                    if [[ "$id" == "$LINODE_ID" ]]; then
                        log "‚ö†Ô∏è Linode ID $LINODE_ID already has a firewall attached (Firewall ID: $FW_ID). Skipping attachment."
                        return 0
                    fi
                done
            done
        
            log "üîó Attaching firewall $FIREWALL_LABEL to Linode instance $LINODE_ID..."
            set +e
            wait_for_dns ‚è≥ Ensure DNS is up before calling Linode API
            linode-cli firewalls device-create "$FIREWALL_ID" --type linode --id "$LINODE_ID"
            ATTACH_STATUS=$?
            set -e
        
            if [[ $ATTACH_STATUS -eq 0 ]]; then
                # Wait for firewall to be fully attached before proceeding
                ATTACH_WAIT_RETRIES=10
                ATTACH_WAIT_DELAY=5
                ATTACH_CONFIRMED=false
                for i in $(seq 1 $ATTACH_WAIT_RETRIES); do
                    set +e
                    wait_for_dns # ‚è≥ Ensure DNS is up before calling Linode API
                    linode-cli firewalls devices-list "$FIREWALL_ID" --json | jq --argjson lid "$LINODE_ID" -e '.[] | select(.entity.id == $lid)' > /dev/null
                    FIREWALL_DEVICE_STATUS=$?
                    set -e
                    if [[ "$FIREWALL_DEVICE_STATUS" -eq 0 ]]; then
                        ATTACH_CONFIRMED=true
                        log "‚úÖ Firewall successfully attached to Linode ID $LINODE_ID"
                        log "üõ°Ô∏è Firewall ENABLED ‚Äì Firewall '$FIREWALL_LABEL' (ID: $FIREWALL_ID) successfully created/attached to instance."
                        log "‚úÖ Firewall attachment complete. Continuing to finalize script execution..."
                        break
                    else
                        log "‚è≥ Waiting for firewall to attach (attempt $i/$ATTACH_WAIT_RETRIES)..."
                        sleep "$ATTACH_WAIT_DELAY"
                    fi
                done
                if [[ "$ATTACH_CONFIRMED" != true ]]; then
                    log "‚ùå Firewall did not attach within expected time for Linode ID $LINODE_ID"
                    sleep infinity
                fi
            else
                log "‚ùå Failed to attach firewall to Linode ID $LINODE_ID. Sleeping indefinitely to avoid container restart loop."
                sleep infinity
            fi
        }
        
        # === Discover Node IP and Name ===
        log "üåê Fetching NODE IP of the instance..."
        NODE_IP=$(ip addr show eth0 | grep -v "eth0:[0-9]" | grep -w inet | awk {'print $2'}|awk -F'/' {'print $1'})
        log "üåê Node IP: $NODE_IP"
        
        log "üåê Fetching NODE NAME of the instance..."
        NODE_NAME=$(kubectl get nodes -o json | jq -r '.items[] | select(.status.addresses[]?.address == "'"$NODE_IP"'") | .metadata.name')
        log "üåê Node Name: $NODE_NAME"
        
        # === VLAN Ready Label Helpers ===
        mark_node_vlan_ready() {
            log "üè∑Ô∏è Marking node '$NODE_NAME' as vlan-ready=true (unblocks app scheduling via Kyverno)..."
            kubectl label node "$NODE_NAME" vlan-ready=true --overwrite
            log "‚úÖ Node label applied: vlan-ready=true"
        }
        
        clear_node_vlan_ready_label() {
            log "üè∑Ô∏è Clearing node '$NODE_NAME' vlan-ready label (blocks app scheduling via Kyverno)..."
            kubectl label node "$NODE_NAME" vlan-ready- 2>/dev/null || true
        }
        
        # === Fetch Public IP of the Node ===
        log "üåê Fetching Public IP of the instance..."
        PUBLIC_IP=$(kubectl get node $NODE_NAME -o jsonpath='{.status.addresses[?(@.type=="ExternalIP")].address}' | awk {'print $1'})
        log "üåê Public IP of the Node: $PUBLIC_IP"
        
        export LINODE_CLI_CONFIG="/root/.linode-cli/linode-cli"
        
        # === Discover Linode ID and Configuration ID ===
        log "üåê Finding Linode ID for Public IP: $PUBLIC_IP"
        LINODE_ID=""
        TARGET_IP="$PUBLIC_IP"
        
        page=1
        while true; do
            log "üîç Searching Linode list: Page $page"
            wait_for_dns
        
            result=$(linode-cli linodes list --page $page --page-size 100 --json)
        
            if [[ $(echo "$result" | jq 'length') -eq 0 ]]; then
                break
            fi
        
            LINODE_ID=$(echo "$result" | jq -r --arg ip "$TARGET_IP" '.[] | select(.ipv4[]? == $ip) | .id')
        
            if [[ -n "$LINODE_ID" ]]; then
                log "‚úÖ Found Linode with IP $TARGET_IP. LINODE_ID: $LINODE_ID"
                break
            fi
        
            page=$((page + 1))
        done
        
        if [[ -z "$LINODE_ID" ]]; then
            log "‚ùå Failed to find Linode with public IP $TARGET_IP."
            exit 1
        fi
        
        wait_for_dns
        CONFIG_ID=$(linode-cli linodes configs-list "$LINODE_ID" --json | jq -r '.[0].id')
        
        if [ -z "$CONFIG_ID" ]; then
            log "‚ùå Failed to retrieve configuration ID for Linode ID $LINODE_ID"
            exit 1
        fi
        
        log "‚úÖ Linode ID: $LINODE_ID, Config ID: $CONFIG_ID"
        
        # === Main Logic ===
        
        # 1) Fix "configured but missing VLAN interface" first (ensures interface exists on OS)
        handle_vlan_configured_but_missing_interface
        
        # 2) Check current interface state
        log "üîé Checking existing VLAN/VPC attachment state for Linode instance $LINODE_ID..."
        VLAN_PRESENT=false
        VPC_PRESENT=false
        
        if is_vlan_attached; then
            VLAN_PRESENT=true
        fi
        if is_vpc_attached; then
            VPC_PRESENT=true
        fi
        
        log "üîé State summary: VLAN_PRESENT=${VLAN_PRESENT}, ENABLE_VPC_INTERFACE=${ENABLE_VPC_INTERFACE}, VPC_PRESENT=${VPC_PRESENT}"
        
        # 2a) If VLAN is attached and VPC is either disabled or already attached => just do routes/firewall and iptables, no reboot
        if [[ "$VLAN_PRESENT" == true && "$ENABLE_VPC_INTERFACE" == "true" && "$VPC_PRESENT" == false ]]; then
            log "‚ÑπÔ∏è VLAN is attached but VPC interface is missing. Attaching VPC and rebooting once..."
            attach_vpc_interface_only
            serialized_reboot
            sleep 300
            log "‚ö†Ô∏è Node did not reboot as expected after VPC attach. Sleeping to avoid loop."
            sleep infinity
        fi
        
        # 2b) VLAN attached and either:
        #     - VPC is disabled (ENABLE_VPC_INTERFACE != true), OR
        #     - VPC is already present
        #     => No config-update, no reboot; just routes/firewall/iptables.
        if [[ "$VLAN_PRESENT" == true ]]; then
            log "‚úÖ VLAN is attached and VPC state is satisfied (either disabled or already present). Skipping config-update and reboot."
            push_route
            create_and_attach_firewall
            configure_vlan_ew_firewall
            # ‚úÖ Unblock application scheduling only after success
            mark_node_vlan_ready
            log "üõå VLAN/VPC configuration and firewall complete. Sleeping indefinitely..."
            sleep infinity
        fi
        
        # 3) VLAN is not attached => allocate VLAN IP and build interfaces list (VLAN + optional VPC), then reboot ONCE
        log "‚ùå VLAN is not attached. Proceeding with VLAN (and optional VPC) configuration..."
        MAX_RETRIES=5
        RETRY_COUNT=0
        SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            log "üîÑ Attempting to allocate IP address... (Attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
        
            set +e
            IP_ADDRESS1=$(/tmp/03-script-ip-allocate.sh $SUBNET)
            STATUS=$?
            set -e
        
            if [ $STATUS -eq 0 ]; then
                IP_ADDRESS=$(echo $IP_ADDRESS1 | awk {'print $NF'})
                if [ -n "$IP_ADDRESS" ]; then
                    log "‚úÖ Allocated IP address: $IP_ADDRESS"
                    SUCCESS=true
                    break
                else
                    log "‚ö†Ô∏è  No IP address found in response. Retrying..."
                fi
            else
                log "‚ùå IP allocation script failed. Retrying..."
            fi
        
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 5
        done
        
        if [ "$SUCCESS" = false ]; then
            log "‚ùå IP allocation failed after $MAX_RETRIES attempts. Retrying in 60 seconds..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        # === Build VLAN (+optional VPC) JSON ===
        log "‚öôÔ∏è  Building VLAN (and optionally VPC) attachment JSON..."
        
        if [[ "$ENABLE_VPC_INTERFACE" == "true" && -n "$VPC_SUBNET_ID" ]]; then
            INTERFACES_JSON=$(jq -n --arg ip "$IP_ADDRESS" --arg vlan "$VLAN_LABEL" --argjson subnet_id "$VPC_SUBNET_ID" '
                [
                  { "type": "public", "purpose": "public" },
                  { "type": "vlan", "label": $vlan, "purpose": "vlan", "ipam_address": $ip },
                  { "purpose": "vpc", "subnet_id": $subnet_id }
                ]
            ')
            log "üì¶ Configuring interfaces: public (eth0), VLAN (eth1), VPC (eth2)"
        else
            INTERFACES_JSON=$(jq -n --arg ip "$IP_ADDRESS" --arg vlan "$VLAN_LABEL" '
                [
                  { "type": "public", "purpose": "public" },
                  { "type": "vlan", "label": $vlan, "purpose": "vlan", "ipam_address": $ip }
                ]
            ')
            log "üì¶ Configuring interfaces: public (eth0), VLAN (eth1)"
        fi
        
        echo "$INTERFACES_JSON" | jq .
        
        # === Attach the VLAN (and optional VPC) interface(s) ===
        log "‚öôÔ∏è  Attaching VLAN (and optional VPC) interface(s) to Linode instance..."
        wait_for_dns # ‚è≥ Ensure DNS is up before calling Linode API
        linode-cli linodes config-update "$LINODE_ID" "$CONFIG_ID" --interfaces "$INTERFACES_JSON" --label "Boot Config"
        
        # === Check VLAN is attached after attachment and then reboot ONCE ===
        if is_vlan_attached; then
            log "‚úÖ VLAN is successfully attached now. Proceeding to reboot for changes to take effect..."
        
            # Mark that this run is performing a reboot so we don't release IP on EXIT
            touch /tmp/rebooting
        
            serialized_reboot
        
            sleep 300
            log "‚ö†Ô∏è Node did not reboot as expected. Sleeping to avoid loop."
            sleep infinity
        else
            log "‚ùå VLAN check failed after config. Retrying in 60s..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 1
        fi
        
        # === Cleanup Logic (currently not reached in normal flow, but kept for safety) ===
        cleanup() {
            if [ -f "/tmp/rebooting" ]; then
                log "Skipping IP release due to planned reboot."
                rm -rfv /tmp/rebooting
            elif [ -n "$IP_ADDRESS" ]; then
                log "Releasing IP address $IP_ADDRESS..."
                /tmp/04-script-ip-release.sh "$IP_ADDRESS"
                log "IP address $IP_ADDRESS released."
            fi
        }
        trap cleanup EXIT
        
        # ‚úÖ Unblock application scheduling only after success
        mark_node_vlan_ready
        
        log "‚úÖ VLAN Attachment completed successfully."
        log "üåê Instance $LINODE_ID is now connected to VLAN $VLAN_LABEL with IP $IP_ADDRESS."
        log "üü¢ VLAN, VPC (if enabled), Routes, Firewall, and VLAN-EW iptables configuration steps completed successfully."
        log "üõå Script execution complete. Sleeping indefinitely..."
        sleep infinity
  03-script-ip-allocate.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP allocation
        API_ENDPOINT="http://vlan-ip-controller-service.kube-system.svc.cluster.local:8080/allocate"
        SUBNET=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$SUBNET" ]; then
            error "No subnet provided for IP allocation."
        fi
        
        log "Requesting IP from API at $API_ENDPOINT for Subnet: $SUBNET..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT \
            -H "Content-Type: application/json" \
            -d "{\"subnet\": \"$SUBNET\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            ALLOCATED_IP=$(echo $RESPONSE_BODY | jq -r '.allocated_ip')
            log "Successfully allocated IP: $ALLOCATED_IP"
            echo $ALLOCATED_IP
        else
            case $HTTP_CODE in
                404)
                    error "API Endpoint not found. Service 'vlan-leader-service' may not be running in namespace 'kube-system'."
                    ;;
                500)
                    error "No IP addresses available in the provided subnet."
                    ;;
                400)
                    error "Bad request. The subnet format is incorrect."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi  
      
  04-script-ip-release.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP release
        API_ENDPOINT="http://vlan-ip-controller-service.kube-system.svc.cluster.local:8080/release"
        IP_ADDRESS=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$IP_ADDRESS" ]; then
            error "No IP address provided for release."
        fi
        
        log "Requesting IP release from API at $API_ENDPOINT for IP: $IP_ADDRESS..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT -H "Content-Type: application/json" -d "{\"ip_address\": \"$IP_ADDRESS\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            log "Successfully released IP: $IP_ADDRESS"
            echo $IP_ADDRESS
        else
            case $HTTP_CODE in
                404)
                    error "IP address $IP_ADDRESS not found in the allocation list."
                    ;;
                400)
                    error "Bad request. Possibly malformed JSON or missing IP address."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi
        
  05-script-ip-list-initialize.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        #!/bin/bash
        # Exit on error
        set -e
        
        # --- Define Color Codes ---
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[1;34m'
        NC='\033[0m' # No Color
        
        LINODE_TOKEN="${LINODE_TOKEN}"
        #LINODE_TOKEN=`grep token /root/.linode-cli/linode-cli | awk -F'= ' {'print $2'}`
        OUTPUT_FILE="/tmp/vlan-ip-list.txt"
        PAGE_SIZE=100
        CURRENT_PAGE=1
        TOTAL_PAGES=1
        MAX_RETRIES=3
        BACKOFF_BASE=2
        INITIAL_JOBS=5
        MAX_JOBS=20
        
        # === Environment Variables ===
        # File path for IP list storage
        IP_FILE_PATH=$OUTPUT_FILE
        
        # Subnet is passed as the first argument
        SUBNET=$1
        REGION=$2
        
        # === Function to Log Events ===
        # This function logs events with timestamps for better traceability
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        # === Validate Subnet is Provided ===
        # If the subnet is not passed as an argument, exit with an error
        log "[DEBUG] Script received SUBNET=$SUBNET REGION=$REGION"
        if [ -z "$SUBNET" ]; then
            log "[ERROR] No subnet provided for initialization."
            exit 1
        fi
        
        # === Validate if Region is Provided ===
        # If the region is not passed as an argument, exit with an error
        if [ -z "$REGION" ]; then
            log "[ERROR] No REGION provided for initialization."
            exit 1
        fi
        
        log "üîÑ Starting IP List Initialization..."
        
        log "üåê Subnet provided for initialization: $SUBNET"
        
        # --- Retry Logic Wrapper with Intelligent Backoff and 404 Handling ---
        retry_curl() {
            local URL=$1
            local OUTPUT=$2
            local RETRY_COUNT=0
            local BACKOFF=1
            local SUCCESS=false
        
            while [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
                echo -e "${BLUE}üåê Attempting API call: $URL (Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)${NC}"
                
                START_TIME=$(date +%s)  # Start timer
        
                if [[ "$URL" == *"/linode/instances/"*"/configs" ]]; then
                    HTTP_CODE=$(curl -s -w "%{http_code}" -H "Authorization: Bearer $LINODE_TOKEN" \
                                "$URL" -o "$OUTPUT")
                else
                    HTTP_CODE=$(curl -s -w "%{http_code}" -H "Authorization: Bearer $LINODE_TOKEN" \
                                -H 'X-Filter: {"region": "'$REGION'"}' \
                                "$URL" -o "$OUTPUT")
                fi
        
                END_TIME=$(date +%s)    # End timer
                DURATION=$((END_TIME - START_TIME))
                echo "$URL | $DURATION ms" >> latency-log.txt
        
                case "$HTTP_CODE" in
                    200)
                        if [ -s "$OUTPUT" ]; then
                            SUCCESS=true
                            echo -e "${GREEN}‚úÖ API call successful ($DURATION ms): $URL${NC}"
                            break
                        fi
                        ;;
                    404)
                        echo -e "${RED}‚ùå [404] Resource not found: $URL${NC}" | tee -a error-log.txt
                        echo -e "${YELLOW}   ‚û°Ô∏è  Skipping further retries for this resource.${NC}"
                        return 1
                        ;;
                    429)
                        echo -e "${YELLOW}‚ö†Ô∏è Rate limit hit. Backing off for $BACKOFF seconds...${NC}"
                        sleep "$BACKOFF"
                        BACKOFF=$((BACKOFF * BACKOFF_BASE))
                        ;;
                    *)
                        echo -e "${RED}‚ö†Ô∏è API call failed with HTTP Code $HTTP_CODE, retrying in $BACKOFF seconds...${NC}"
                        sleep "$BACKOFF"
                        BACKOFF=$((BACKOFF * BACKOFF_BASE))
                        ;;
                esac
        
                ((RETRY_COUNT++))
            done
        
            if [ "$SUCCESS" = false ] && [ "$HTTP_CODE" != "404" ]; then
                echo -e "${RED}‚ùå API call failed after $MAX_RETRIES attempts: $URL${NC}" | tee -a error-log.txt
            fi
        }
        
        # --- Step 1: Paginated Fetch for All Linode IDs in the region with X-Filter ---
        echo -e "${BLUE}üåê Fetching Linode IDs in region $REGION with Pagination...${NC}"
        while [ "$CURRENT_PAGE" -le "$TOTAL_PAGES" ]; do
            echo -e "${BLUE}   ‚û°Ô∏è  Fetching page $CURRENT_PAGE of $TOTAL_PAGES${NC}"
            
            URL="https://api.linode.com/v4/linode/instances?page=$CURRENT_PAGE&page_size=$PAGE_SIZE"
            TEMP_RESPONSE=$(mktemp)
            
            # Fetch paginated data with retry logic
            retry_curl "$URL" "$TEMP_RESPONSE"
            
            # Fetch Linode IDs and append to file
            cat "$TEMP_RESPONSE" | jq -r '.data[] | .id' >> linodes.txt
            
            # Get pagination info
            TOTAL_PAGES=$(cat "$TEMP_RESPONSE" | jq -r '.pages')
            CURRENT_PAGE=$((CURRENT_PAGE + 1))
            rm -f "$TEMP_RESPONSE"
        done
        
        # --- Step 2: Count the number of Linode IDs and adjust MAX_JOBS ---
        TOTAL_LINODES=$(wc -l < linodes.txt)
        if [ "$TOTAL_LINODES" -lt "$INITIAL_JOBS" ]; then
            MAX_JOBS="$TOTAL_LINODES"
        else
            # --- Adjust parallel jobs based on latency ---
            AVG_LATENCY=$(awk '{sum+=$3} END {print int(sum/NR)}' latency-log.txt)
            
            if [ "$AVG_LATENCY" -lt 200 ]; then
                MAX_JOBS=20
            elif [ "$AVG_LATENCY" -lt 500 ]; then
                MAX_JOBS=10
            else
                MAX_JOBS=5
            fi
        fi
        
        echo -e "${GREEN}üîé Found $TOTAL_LINODES Linode IDs. Adjusting parallel jobs to $MAX_JOBS (Avg Latency: $AVG_LATENCY ms)${NC}"
        
        # --- Step 3: Function to fetch VLAN IPs for a single Linode ---
        fetch_vlan_ips() {
            local LID=$1
            local TEMP_FILE=$(mktemp)
            local TEMP_RESPONSE=$(mktemp)
            echo -e "${GREEN}üîé Checking Linode ID: $LID${NC}"
        
            # Fetch configurations for the Linode with retry logic and X-Filter for interfaces
            URL="https://api.linode.com/v4/linode/instances/$LID/configs"
            retry_curl "$URL" "$TEMP_RESPONSE"
        
            if [ $? -ne 0 ]; then
                echo -e "${RED}‚ùå [ERROR] Failed to fetch configs for Linode ID $LID${NC}" | tee -a error-log.txt
                return 1
            fi
        
            # Extract VLAN IPs directly (No additional curl calls)
            VLAN_IPS=$(cat "$TEMP_RESPONSE" | jq -r ".data[].interfaces[] | select(.purpose == \"vlan\") | .ipam_address")
        
            # Write to the temp file and success log
            if [ -n "$VLAN_IPS" ]; then
                echo "$VLAN_IPS" >> "$TEMP_FILE"
                echo -e "${GREEN}‚úÖ [SUCCESS] VLAN IPs found for Linode ID $LID - $VLAN_IPS${NC}" | tee -a success-log.txt
            else
                echo -e "${YELLOW}‚ö†Ô∏è [INFO] No VLAN IPs found for Linode ID $LID${NC}" | tee -a success-log.txt
            fi
        
            # Append temp file to final output (atomic operation)
            if [ -s "$TEMP_FILE" ]; then
                cat "$TEMP_FILE" >> "$OUTPUT_FILE"
            fi
        
            rm -f "$TEMP_FILE" "$TEMP_RESPONSE"
        }
        
        # === Calculate IP addresses without ipcalc ===
        NETWORK_PREFIX=$(echo $SUBNET | cut -d'/' -f2)
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo $SUBNET | cut -d'/' -f1)"
        
        # Extract the IP segments correctly
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo "$SUBNET" | cut -d'/' -f1)"
        
        # Sanity check
        if [ -z "$i1" ] || [ -z "$i2" ] || [ -z "$i3" ]; then
            echo -e "${RED}[ERROR] Subnet parsing failed. Please check the subnet format.${NC}"
            exit 1
        fi
        
        # Network IP (x.x.x.0)
        NETWORK_IP="${i1}.${i2}.${i3}.0/$NETWORK_PREFIX"
        
        # First usable IP (x.x.x.1)
        FIRST_IP="${i1}.${i2}.${i3}.1/$NETWORK_PREFIX"
        
        # Broadcast IP (x.x.x.255)
        BROADCAST_IP="${i1}.${i2}.${i3}.255/$NETWORK_PREFIX"
        
        # Reserved IPs Array
        RESERVED_IPS=("$NETWORK_IP" "$FIRST_IP" "$BROADCAST_IP")
        
        log "Reserved IPs for subnet $SUBNET: ${RESERVED_IPS[*]}"
        
        # Adding reserved IPs to $IP_FILE_PATH files
        log "Adding reserved IPs to the allocation list for reserving it..."
        for ip in "${RESERVED_IPS[@]}"; do
            if ! grep -q "^$ip$" "$IP_FILE_PATH"; then
                echo "$ip" >> "$IP_FILE_PATH"
                log "Reserved IP added to list: $ip"
            fi
        done
        
        # --- Export function and variables for parallel ---
        export -f fetch_vlan_ips retry_curl
        export LINODE_TOKEN OUTPUT_FILE MAX_RETRIES
        
        # --- Step 4: Parallel Processing of Linode IDs ---
        echo -e "${BLUE}üåê Fetching VLAN IPs from configurations in parallel...${NC}"
        cat linodes.txt | parallel -j "$MAX_JOBS" fetch_vlan_ips {}
        
        # --- Cleanup ---
        rm -f linodes.txt
        
        # === Remove duplicates ===
        sort -u "$OUTPUT_FILE" -o "$OUTPUT_FILE"
        
        log "‚úÖ VLAN IP file created at $OUTPUT_FILE"
        
        # === Write to etcd using etcdctl txn ===
        log "üíæ Syncing IPs to etcd..." 
        log "‚úÖ ETCD_ENDPOINTS is $ETCD_ENDPOINTS"
        
        if [ -z "$ETCD_ENDPOINTS" ]; then
            log "[ERROR] ETCD_ENDPOINTS not set."
            exit 1
        fi
        
        export ETCDCTL_API=3     
        
        while IFS= read -r ip; do
            key="/vlan/ip/$ip"
            output=$(etcdctl --endpoints="$ETCD_ENDPOINTS" put --prev-kv "$key" "true" 2>&1)
            if [[ "$output" == *"prev_kv"* ]]; then
                log "üîÅ IP $ip already exists in etcd, skipping."
            else
                log "‚úÖ IP $ip synced to etcd."
            fi
        done < "$OUTPUT_FILE"
        
        log "üéâ Initialization and etcd sync complete."

        echo -e "${GREEN}‚úÖ VLAN IP Initialization Complete. IPs saved to etcd database."
        
        # --- Final Output ---
        cat "$OUTPUT_FILE"
        
        log "‚úÖ IP List Initialization Complete. Saved to $IP_FILE_PATH"
  06-rest-api.py: |
        # Import necessary libraries for web server, concurrency, networking, and file handling
        from flask import Flask, jsonify, request
        from flask_cors import CORS
        import os
        import ipaddress
        import sys
        import time
        import requests
        import random
        import signal
        import configparser
        import yaml
        import uuid
        import psutil
        from datetime import datetime
        from filelock import FileLock
        
        import etcd3
        from kubernetes import client, config
        
        app = Flask(__name__)
        CORS(app)
        
        LOG_FILE = "/tmp/allocate-ip.log"
        MAX_LOG_LINES = 1000
        MAX_BACKOFF = 60
        
        VLAN_IP_CACHE = {
            "ips": None,
            "timestamp": None,
            "ttl_seconds": int(os.getenv("CACHE_TTL_SECONDS", 0)),
        }
        
        REGION_CACHE = {"valid": False, "timestamp": None, "ttl_seconds": 3600}
        
        
        def graceful_exit(signalnum, frame):
            log(f"[INFO] Received signal {signalnum}. Shutting down gracefully...")
            sys.exit(0)
        
        
        signal.signal(signal.SIGTERM, graceful_exit)
        signal.signal(signal.SIGINT, graceful_exit)
        
        def validate_environment():
            REGION = os.getenv("REGION")
            if not REGION:
                log("[ERROR] REGION environment variable not set.")
                sys.exit(1)
            if not os.getenv("ETCD_ENDPOINTS"):
                log("[ERROR] ETCD_ENDPOINTS environment variable not set.")
                sys.exit(1)
            log("[INFO] Environment validation passed.")
        
        
        def log(message: str):
            timestamped_message = f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {message}"
            print(timestamped_message)
            sys.stdout.flush()
        
            try:
                with FileLock(LOG_FILE + ".lock"):
                    lines = []
                    if os.path.exists(LOG_FILE):
                        with open(LOG_FILE, "r") as f:
                            lines = f.read().splitlines()
        
                    lines.append(timestamped_message)
                    lines = lines[-MAX_LOG_LINES:]
        
                    with open(LOG_FILE, "w") as f:
                        f.write("\n".join(lines) + "\n")
            except Exception as e:
                print(f"[ERROR] Failed to write to log file: {str(e)}")
        
        def _sleep_with_backoff(base_backoff, attempt, jitter=True):
            wait_time = min(base_backoff * (2 ** (attempt - 1)), MAX_BACKOFF)
            if jitter:
                wait_time += random.uniform(0.1, 0.5)
            log(f"[DEBUG] Waiting {wait_time:.2f}s before retrying...")
            time.sleep(wait_time)
        
        def api_request_with_retry(url, headers, retries=3, backoff=2, jitter=True):
            for attempt in range(1, retries + 1):
                try:
                    response = requests.get(url, headers=headers, timeout=8)
        
                    if response.status_code == 200:
                        try:
                            return response.json()
                        except ValueError:
                            log(f"[ERROR] Invalid JSON response on attempt {attempt}: {response.text}")
                            return None
        
                    if response.status_code == 429:
                        wait_time = int(response.headers.get("Retry-After", 5))
                        log(f"[WARN] Rate limited (429). Retrying after {wait_time}s (attempt {attempt}/{retries})")
                        time.sleep(wait_time)
                        continue
        
                    if response.status_code >= 500:
                        log(f"[WARN] Server error {response.status_code} on attempt {attempt}. Retrying...")
                        _sleep_with_backoff(backoff, attempt, jitter)
                        continue
        
                    log(f"[WARN] API error {response.status_code} on attempt {attempt}. Retrying...")
                    _sleep_with_backoff(backoff, attempt, jitter)
        
                except (requests.ConnectionError, requests.Timeout) as e:
                    log(f"[ERROR] Network error on attempt {attempt}: {str(e)}. Retrying...")
                    _sleep_with_backoff(backoff, attempt, jitter)
                except requests.RequestException as e:
                    log(f"[ERROR] Unexpected error on attempt {attempt}: {str(e)}. Retrying...")
                    _sleep_with_backoff(backoff, attempt, jitter)
        
            log(f"[ERROR] API call failed after {retries} attempts.")
            return None
        
        def normalize_ip(s: str) -> str:
            """
            Normalize anything like '192.168.0.10', '192.168.0.10/24', ' 192.168.0.10/24 '
            into bare IP: '192.168.0.10'
            """
            if not s:
                return ""
            s = s.strip()
            return s.split("/", 1)[0].strip()
        
        def fetch_linode_token(config_file="/root/.linode-cli/linode-cli"):
            if not os.path.exists(config_file):
                log(f"[ERROR] Configuration file {config_file} not found")
                return None
        
            cfg = configparser.ConfigParser()
            try:
                cfg.read(config_file)
        
                if "DEFAULT" not in cfg or "default-user" not in cfg["DEFAULT"]:
                    log(f"[ERROR] No 'default-user' found in {config_file}")
                    return None
        
                default_user = cfg["DEFAULT"]["default-user"]
                if default_user not in cfg:
                    log(f"[ERROR] User profile '{default_user}' not found in {config_file}")
                    return None
        
                token = cfg[default_user].get("token")
                if not token:
                    log(f"[ERROR] No token found for user '{default_user}' in {config_file}")
                    return None
        
                return token
            except Exception as e:
                log(f"[ERROR] Exception while reading configuration file: {str(e)}")
                return None
        
        def fetch_assigned_ips():
            # Cache
            if (
                VLAN_IP_CACHE["ips"] is not None
                and VLAN_IP_CACHE["timestamp"] is not None
                and (datetime.now() - VLAN_IP_CACHE["timestamp"]).total_seconds() < VLAN_IP_CACHE["ttl_seconds"]
            ):
                log("[INFO] Using cached VLAN IPs")
                return VLAN_IP_CACHE["ips"]
        
            LINODE_TOKEN = fetch_linode_token()
            REGION = os.getenv("REGION")
            if not REGION:
                log("[ERROR] REGION environment variable not set")
                return []
        
            if not LINODE_TOKEN:
                log("[ERROR] Missing Linode Token")
                return []
        
            headers = {"Authorization": f"Bearer {LINODE_TOKEN}"}
            log(f"[DEBUG] Fetching Linode instances in region: {REGION}")
        
            vlan_ips = []
            page = 1
            total_pages = 1
        
            while page <= total_pages:
                url = f"https://api.linode.com/v4/linode/instances?page={page}&page_size=100"
                response = api_request_with_retry(url, headers={**headers, "X-Filter": f'{{"region": "{REGION}"}}'})
                if not response or "data" not in response:
                    log(f"[ERROR] Failed to fetch instances on page {page}")
                    break
        
                if page == 1:
                    total_pages = response.get("pages", 1)
                    log(f"[DEBUG] Total pages of instances: {total_pages}")
        
                for linode in response["data"]:
                    linode_id = linode.get("id")
                    if not linode_id:
                        continue
        
                    config_list_url = f"https://api.linode.com/v4/linode/instances/{linode_id}/configs"
                    configs = api_request_with_retry(config_list_url, headers=headers)
                    if not configs or "data" not in configs:
                        continue
        
                    for c in configs["data"]:
                        cid = c.get("id")
                        if not cid:
                            continue
        
                        config_view_url = f"https://api.linode.com/v4/linode/instances/{linode_id}/configs/{cid}"
                        config_view = api_request_with_retry(config_view_url, headers=headers)
                        if not config_view or "interfaces" not in config_view:
                            continue
        
                        for iface in config_view["interfaces"]:
                            if iface.get("purpose") == "vlan":
                                ipam = iface.get("ipam_address")
                                if ipam:
                                    ip = normalize_ip(ipam)
                                    if ip:
                                        vlan_ips.append(ip)
                                        log(f"[DEBUG] Found VLAN IP from Linode: {ip}")
        
                page += 1
        
            VLAN_IP_CACHE["ips"] = vlan_ips
            VLAN_IP_CACHE["timestamp"] = datetime.now()
            log(f"[INFO] Total VLAN IPs fetched: {len(vlan_ips)}")
            return vlan_ips
        
        def system_health_check():
            load_avg = os.getloadavg()
            mem = psutil.virtual_memory()
            if load_avg[0] > os.cpu_count() * 2:
                log("[WARN] High system load detected")
                return False
            if mem.percent > 90:
                log("[WARN] High memory usage detected")
                return False
            return True
        
        def get_etcd_connection():
            endpoints = os.getenv("ETCD_ENDPOINTS", "")
            if not endpoints:
                raise EnvironmentError("ETCD_ENDPOINTS not set in environment")
        
            for ep in endpoints.split(","):
                ep = ep.strip().replace("http://", "").replace("https://", "").rstrip("/")
                parts = ep.split(":")
                if len(parts) != 2:
                    log(f"[ERROR] Invalid ETCD endpoint format: {ep}. Expected format: host:port")
                    continue
        
                host = parts[0]
                try:
                    port = int(parts[1])
                except ValueError:
                    log(f"[ERROR] Port is not a valid integer in endpoint: {ep}")
                    continue
        
                try:
                    c = etcd3.client(host=host, port=port)
                    c.status()
                    log(f"[INFO] Connected to etcd: {host}:{port}")
                    return c
                except Exception as e:
                    log(f"[WARN] Failed to connect to etcd endpoint {host}:{port}: {str(e)}")
                    continue
        
            raise ConnectionError("Unable to connect to any etcd endpoint")
        
        
        def get_etcd():
            endpoints = os.getenv("ETCD_ENDPOINTS", "").split(",")
            for ep in endpoints:
                ep = ep.strip().replace("http://", "").replace("https://", "").rstrip("/")
                if not ep:
                    continue
                if ":" in ep:
                    host, port = ep.split(":")
                else:
                    host, port = ep, "2379"
                try:
                    c = etcd3.client(host=host, port=int(port))
                    c.status()
                    return c
                except Exception:
                    continue
            raise RuntimeError("No healthy etcd endpoints")
        
        def k8s_api():
            try:
                config.load_incluster_config()
            except Exception:
                config.load_kube_config()
            return client.BatchV1Api(), client.CoreV1Api()
        
        def reserved_set(ip_net: ipaddress.IPv4Network) -> set:
            """
            Reserved:
              - network address (x.x.x.0)
              - first usable host (x.x.x.1 if available)
              - broadcast address (x.x.x.255)
            """
            res = set()
            res.add(str(ip_net.network_address))
            res.add(str(ip_net.broadcast_address))
            # first usable host if any
            hosts = list(ip_net.hosts())
            if hosts:
                res.add(str(hosts[0]))
            return res
        
        @app.route("/allocate", methods=["POST"])
        
        def allocate_ip():
            try:
                data = request.get_json(silent=True) or {}
                subnet = data.get("subnet")
                if not subnet:
                    log("[ERROR] Subnet not provided")
                    return jsonify({"error": "Subnet not provided"}), 400
        
                REGION = os.getenv("REGION")
                if not REGION:
                    log("[ERROR] REGION not provided")
                    return jsonify({"error": "Region not provided"}), 400
        
                try:
                    ip_net = ipaddress.ip_network(subnet, strict=False)
                    cidr_suffix = f"/{ip_net.prefixlen}"
                except ValueError:
                    log("[ERROR] Invalid subnet format")
                    return jsonify({"error": "Invalid subnet format"}), 400
        
                etcd = get_etcd_connection()
        
                # ---- Build used IP set from etcd (normalize BOTH old + new styles) ----
                etcd_used_bare = set()
                for _value, meta in etcd.get_prefix("/vlan/ip/"):
                    if not meta.key:
                        continue
                    key = meta.key.decode("utf-8")
                    raw = key.replace("/vlan/ip/", "", 1)        # may be '192.168.0.10' or '192.168.0.10/24'
                    bare = normalize_ip(raw)
                    if bare:
                        etcd_used_bare.add(bare)
        
                # ---- Add Linode assigned VLAN IPs (bare) ----
                linode_assigned_bare = set(fetch_assigned_ips() or [])
                used_bare = etcd_used_bare.union(linode_assigned_bare)
        
                # ---- Sync Linode IPs into etcd using canonical bare key (atomic-ish) ----
                for bare in (linode_assigned_bare - etcd_used_bare):
                    key_bare = f"/vlan/ip/{bare}"
                    payload = {
                        "status": "allocated",
                        "source": "linode-sync",
                        "region": REGION,
                        "subnet": str(ip_net),
                        "allocated_at": datetime.utcnow().isoformat() + "Z",
                        "linode_id": None,
                        "notes": "Discovered via Linode API",
                    }
                    try:
                        etcd.transaction(
                            compare=[etcd.transactions.version(key_bare) == 0],
                            success=[etcd.transactions.put(key_bare, yaml.safe_dump(payload))],
                            failure=[],
                        )
                        log(f"[SYNC] Added Linode-assigned IP to etcd (bare key): {bare}")
                    except Exception as e:
                        log(f"[WARN] Failed syncing {bare}: {str(e)}")
        
                # Recompute
                used_bare = used_bare.union(linode_assigned_bare)
        
                res = reserved_set(ip_net)
        
                # Iterate usable hosts only (safe)
                for host_ip in ip_net.hosts():
                    bare = str(host_ip)
        
                    if bare in res:
                        log(f"[INFO] Skipping Reserved IP: {bare}")
                        continue
        
                    if bare in used_bare:
                        continue
        
                    # Canonical key (NEW)
                    key_bare = f"/vlan/ip/{bare}"
        
                    # Old key style (if your initializer still writes it): /vlan/ip/<ip>/<prefix>
                    key_old_cidr = f"/vlan/ip/{bare}{cidr_suffix}"
        
                    payload = {
                        "status": "allocated",
                        "source": "api-allocate",
                        "region": REGION,
                        "subnet": str(ip_net),
                        "allocated_at": datetime.utcnow().isoformat() + "Z",
                        "linode_id": None,
                        "notes": "",
                    }
        
                    try:
                        # Transaction: allocate ONLY if neither bare-key nor old-cidr-key exists
                        ok, _ = etcd.transaction(
                            compare=[
                                etcd.transactions.version(key_bare) == 0,
                                etcd.transactions.version(key_old_cidr) == 0,
                            ],
                            success=[
                                etcd.transactions.put(key_bare, yaml.safe_dump(payload)),
                            ],
                            failure=[],
                        )
        
                        if ok:
                            allocated_cidr = f"{bare}{cidr_suffix}"
                            log(f"[SUCCESS] Allocated IP: {allocated_cidr} (stored as bare key {key_bare})")
                            return jsonify({
                                "allocated_ip": allocated_cidr,   # backward compatible
                                "ip": bare,                       # useful for UI/logic
                                "cidr": cidr_suffix
                            }), 200
        
                    except Exception as e:
                        log(f"[ERROR] etcd transaction failed for {bare}: {str(e)}")
                        return jsonify({"error": f"Failed to allocate IP: {str(e)}"}), 500
        
                msg = f"No IPs available in subnet {subnet}. Used={len(used_bare)}, Reserved={len(res)}"
                log(f"[ERROR] {msg}")
                return jsonify({"error": msg}), 400
        
            except Exception as e:
                log(f"[ERROR] Unexpected error in /allocate endpoint: {str(e)}")
                return jsonify({"error": f"Unexpected error: {str(e)}"}), 500
        
        
        @app.route("/release", methods=["POST"])
        
        def release_ip():
            try:
                data = request.get_json(silent=True) or {}
                ip_address = data.get("ip_address")
                if not ip_address:
                    return jsonify({"error": "IP address not provided"}), 400
        
                REGION = os.getenv("REGION")
                SUBNET = os.getenv("SUBNET")
                if not REGION or not SUBNET:
                    return jsonify({"error": "Missing REGION or SUBNET env variable"}), 500
        
                try:
                    ip_net = ipaddress.ip_network(SUBNET, strict=False)
                    cidr_suffix = f"/{ip_net.prefixlen}"
                except Exception:
                    return jsonify({"error": "Invalid SUBNET env variable"}), 500
        
                bare = normalize_ip(ip_address)
        
                # reserved protection
                if bare in reserved_set(ip_net):
                    log(f"[WARN] Attempted to release reserved IP: {bare}")
                    return jsonify({"error": f"IP address {bare} is reserved and cannot be released."}), 403
        
                etcd = get_etcd_connection()
        
                key_bare = f"/vlan/ip/{bare}"
                key_old_cidr = f"/vlan/ip/{bare}{cidr_suffix}"
        
                deleted_any = False
                try:
                    if etcd.delete(key_bare):
                        deleted_any = True
                    if etcd.delete(key_old_cidr):
                        deleted_any = True
                except Exception as e:
                    log(f"[ERROR] Release failed: {str(e)}")
                    return jsonify({"error": f"Release failed: {str(e)}"}), 500
        
                if deleted_any:
                    log(f"[INFO] Released IP from etcd: {bare} (deleted bare and/or old cidr key)")
                    return jsonify({"status": "IP released", "ip": bare}), 200
        
                log(f"[WARN] IP {bare} not found in etcd")
                return jsonify({"error": f"IP address {bare} not found in etcd"}), 404
        
            except Exception as e:
                log(f"[ERROR] Unexpected error in /release endpoint: {str(e)}")
                return jsonify({"error": f"Unexpected error: {str(e)}"}), 500
        
        @app.route("/health", methods=["GET"])
        
        def health_check():
            try:
                linode_token = fetch_linode_token()
                if not linode_token:
                    log("[ERROR] Health check: Failed to validate Linode CLI configuration")
                    return jsonify({"status": "unhealthy", "error": "Invalid Linode CLI configuration"}), 500
        
                headers = {"Authorization": f"Bearer {linode_token}"}
                REGION = os.getenv("REGION")
                if not REGION:
                    log("[ERROR] Health check: REGION environment variable not set")
                    return jsonify({"status": "unhealthy", "error": "REGION environment variable not set"}), 500
        
                start_time = time.time()
                response = requests.get("https://api.linode.com/v4/account", headers=headers, timeout=8)
                latency_ms = (time.time() - start_time) * 1000
        
                if response.status_code == 401:
                    return jsonify({"status": "unhealthy", "error": "Unauthorized access"}), 500
                if response.status_code != 200:
                    return jsonify({"status": "unhealthy", "error": "Failed to connect to Linode API"}), 500
        
                response = requests.get("https://api.linode.com/v4/networking/ips", headers=headers, timeout=8)
                if response.status_code != 200:
                    return jsonify({"status": "unhealthy", "error": "Failed to access networking API"}), 500
        
                # etcd
                etcd = get_etcd_connection()
                etcd.status()
        
                if not system_health_check():
                    return jsonify({"status": "unhealthy", "error": "System health checks failed"}), 500
        
                return jsonify({"status": "healthy", "latency_ms": latency_ms}), 200
        
            except Exception as e:
                log(f"[ERROR] Health check: {str(e)}")
                return jsonify({"status": "unhealthy", "error": str(e)}), 500
        
        @app.get("/api/v1/vlan-ips")
        
        def list_ips():
            prefix = os.getenv("ETCD_PREFIX", "/vlan/ip/")
            ips = []
            etcd = get_etcd()
        
            for _value, meta in etcd.get_prefix(prefix):
                key = meta.key.decode()
                raw = key.split(prefix, 1)[1]
                bare = normalize_ip(raw)
                if bare:
                    ips.append(bare)
        
            ips = sorted(set(ips), key=lambda s: [int(x) for x in s.split(".")])
            return jsonify({"ips": ips})
        
        @app.post("/api/v1/refresh")
        
        def refresh():
            ns = os.getenv("NAMESPACE", "kube-system")
            manifest_path = "/manifests/05-vlan-ip-initializer-job.yaml"
        
            with open(manifest_path, "r") as f:
                job_def = yaml.safe_load(f)
        
            base_name = job_def["metadata"]["name"]
            run_name = f"{base_name}-{uuid.uuid4().hex[:6]}"
            job_def["metadata"]["name"] = run_name
            job_def["metadata"]["namespace"] = ns
        
            batch, _ = k8s_api()
            batch.create_namespaced_job(namespace=ns, body=job_def)
            return jsonify({"jobName": run_name})
        
        @app.get("/api/v1/refresh/<job_name>/detail")
        def refresh_detail(job_name):
            ns = os.getenv("NAMESPACE", "kube-system")
            batch, core = k8s_api()
            job = batch.read_namespaced_job_status(job_name, ns)
        
            status = "Running"
            started_at = job.status.start_time.isoformat() if job.status.start_time else None
            completed_at = None
        
            if job.status.completion_time:
                completed_at = job.status.completion_time.isoformat()
                status = "Succeeded"
        
            for c in (job.status.conditions or []):
                if c.type == "Failed" and c.status == "True":
                    status = "Failed"
                    if not completed_at and c.last_transition_time:
                        completed_at = c.last_transition_time.isoformat()
        
            # best-effort pod logs
            pod_name, logs = None, ""
            pods = core.list_namespaced_pod(ns)
            for p in pods.items:
                if p.metadata and p.metadata.name and job_name in p.metadata.name:
                    pod_name = p.metadata.name
                    try:
                        logs = core.read_namespaced_pod_log(name=pod_name, namespace=ns, tail_lines=500)
                    except Exception:
                        pass
                    break
        
            return jsonify({
                "status": status,
                "startedAt": started_at,
                "completedAt": completed_at,
                "podName": pod_name,
                "logs": logs,
            })
        
        
        if __name__ == "__main__":
            validate_environment()
            #print("DEBUG VLAN IPs from Linode:", fetch_assigned_ips())
            #app.run(host="0.0.0.0", port=8080, debug=True)
            app.run(host="0.0.0.0", port=8080, debug=False)
