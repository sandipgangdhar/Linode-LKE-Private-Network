# 04-vlan-manager-scripts-configmap.yaml
# 
# This YAML file defines the ConfigMap for VLAN Manager scripts in Linode LKE.
# It includes the following scripts for IP allocation, release, VLAN attachment,
# and IP list initialization:
# 
# 1Ô∏è‚É£ 02-script-vlan-attach.sh   - Attaches the VLAN to the Linode instance and sets up routing.
# 2Ô∏è‚É£ 03-script-ip-allocate.sh   - Allocates an IP address from the subnet.
# 3Ô∏è‚É£ 04-script-ip-release.sh    - Releases the IP address back to the pool.
# 4Ô∏è‚É£ 05-script-ip-list-initialize.sh - Initializes the IP list from the subnet.
# 5Ô∏è‚É£ 06-rest-api.py             - REST API to manage IP allocation and release.
# 
# -----------------------------------------------------
# üìù Parameters:
# 
# 1Ô∏è‚É£ SUBNET            - Subnet for IP allocation.
# 2Ô∏è‚É£ ROUTE_IP          - Gateway IP for the primary subnet.
# 3Ô∏è‚É£ VLAN_LABEL        - VLAN identifier for Linode.
# 4Ô∏è‚É£ DEST_SUBNET       - Destination subnet for routing.
# 5Ô∏è‚É£ API_ENDPOINT      - URL for IP allocation and release.
# 
# -----------------------------------------------------
# üîÑ Usage:
# 
# - These scripts are mounted into the VLAN Manager Pod and executed during
#   VLAN attachment, IP allocation, and IP release processes.
# - Communication is handled through the configured API endpoints.
# 
# -----------------------------------------------------
# üìå Best Practices:
# 
# - Ensure the VLAN label and subnet are correctly configured before running.
# - Monitor logs for connectivity issues during VLAN attachment.
# - Use health checks to validate API availability before IP allocation.
# 
# -----------------------------------------------------
# üñãÔ∏è Author:
# - Sandip Gangdhar
# - GitHub: https://github.com/sandipgangdhar
# 
# ¬© Linode-LKE-Private-Network | Developed by Sandip Gangdhar | 2025
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vlan-manager-scripts
  namespace: kube-system
data:
  02-script-vlan-attach.sh: |
        #!/bin/bash
        set -e
        
        # === Environment Variables ===
        # These variables are populated from Kubernetes ConfigMap or environment
        SUBNET="${SUBNET}"
        ROUTE_IP="${ROUTE_IP}"
        VLAN_LABEL="${VLAN_LABEL}"
        DEST_SUBNET="${DEST_SUBNET}"
        ENABLE_PUSH_ROUTE="$(echo "$ENABLE_PUSH_ROUTE" | tr '[:upper:]' '[:lower:]')"  # flag to control route pushing
        ENABLE_FIREWALL="$(echo "$ENABLE_FIREWALL" | tr '[:upper:]' '[:lower:]')" # flag to control FIREWALL Creation and attachment
        LKE_CLUSTER_ID="${LKE_CLUSTER_ID}"
        
        # === Function to Log Events ===
        # This function logs events with a timestamp
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        log "üîÑ Starting VLAN Attachment Script..."
        
        # === Function to check if VLAN is already attached ===
        is_vlan_attached() {
            VLAN_STATUS=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].purpose // empty')
            if [ "$VLAN_STATUS" == "vlan" ]; then
                return 0
            else
                return 1
            fi
        }
        
        # === Function to push the route ===
        push_route() {
            if [[ "$ENABLE_PUSH_ROUTE" == "true" ]]; then
        
                # === Route Push Validation Logic ===
                # This block conditionally validates routing variables only if route pushing is enabled.
                #
                # - ENABLE_PUSH_ROUTE: If set to "true", the script will attempt to push a static route.
                # - ROUTE_IP and DEST_SUBNET must be set with valid non-placeholder values if ENABLE_PUSH_ROUTE is true.
                #
                # If ENABLE_PUSH_ROUTE is "false" (default), this block is skipped entirely and
                # ROUTE_IP / DEST_SUBNET are ignored.
                #
                # Note: Even if ignored, placeholder values like "0.0.0.0" should be provided in the ConfigMap
                #       to maintain Kubernetes YAML consistency.
        
                if [[ -z "$ROUTE_IP" || "$ROUTE_IP" == "0.0.0.0" || -z "$DEST_SUBNET" || "$DEST_SUBNET" == "0.0.0.0/0" ]]; then
                    log "‚ùå ENABLE_PUSH_ROUTE is true, but ROUTE_IP or DEST_SUBNET is unset or invalid."
                    log "üõë Skipping route push and sleeping indefinitely to avoid container crash loop."
                    sleep infinity
                fi
                log "üì¶ ENABLE_PUSH_ROUTE value is: $ENABLE_PUSH_ROUTE"
                log "üì¶ ROUTE_IP value is: $ROUTE_IP"
                log "üì¶ DEST_SUBNET value is: $DEST_SUBNET"
        
                log "Checking if route already exists for $DEST_SUBNET..."
            
                # Temporarily disable exit-on-error
                set +e
                ip route show | grep -q "$DEST_SUBNET"
                STATUS=$?
                set -e
                
                if [ $STATUS -eq 0 ]; then
                    log "‚úÖ Route $DEST_SUBNET already exists. Skipping addition."
                else
                    log "‚öôÔ∏è  Adding route $DEST_SUBNET via $ROUTE_IP on eth1..."
                    
                    # Attempt to add the route
                    set +e
                    ip route add "$DEST_SUBNET" via "$ROUTE_IP" dev eth1
                    ADD_STATUS=$?
                    set -e
            
                    if [ $ADD_STATUS -eq 0 ]; then
                        log "‚úÖ Route $DEST_SUBNET via $ROUTE_IP successfully added to eth1."
                    else
                        log "‚ö†Ô∏è  Failed to add route $DEST_SUBNET via $ROUTE_IP. It may already exist."
                    fi
                fi
            else
                log "‚ÑπÔ∏è Skipping route push as ENABLE_PUSH_ROUTE is set to false."
            fi
        }
        
        # === Function to create and attach firewall ===
        create_and_attach_firewall() {
            if [[ "$ENABLE_FIREWALL" != "true" ]]; then
                log "‚ÑπÔ∏è Skipping firewall creation as ENABLE_FIREWALL is set to false."
                return 0
            fi

            FIREWALL_LABEL="lke-cluster-firewall-${LKE_CLUSTER_ID}"
            log "üîç Checking if firewall '$FIREWALL_LABEL' already exists..."

            set +e
            FIREWALL_ID=$(linode-cli firewalls list --json 2>/dev/null | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
            set -e

            if [[ -z "$FIREWALL_ID" ]]; then
                log "üöÄ Creating new firewall with label $FIREWALL_LABEL..."
                set +e
                CREATE_OUTPUT=$(linode-cli firewalls create \
                  --label "$FIREWALL_LABEL" \
                  --rules.inbound='[
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "10250,10256", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Kubelet_Health_Checks"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "51820", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "kubectl_proxy_Wireguard_tunnel"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "53", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "TCP_cluster_DNS_access"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "53", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "UDP_cluster_DNS_access"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "179", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Calico_BGP_traffic"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "5473", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Calico_Typha_traffic"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "30000-32767", "addresses": { "ipv4": ["192.168.255.0/24"] }, "label": "NodeBalancer_TCP"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "30000-32767", "addresses": { "ipv4": ["192.168.255.0/24"] }, "label": "NodeBalancer_UDP"},
                    {"action": "ACCEPT", "protocol": "IPENCAP", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "NP_CP_communication"}
                  ]' \
                  --rules.outbound='[
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "1-65535", "addresses": { "ipv4": ["0.0.0.0/0"] }, "label": "Allow_All_TCP_Outbound"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "1-65535", "addresses": { "ipv4": ["0.0.0.0/0"] }, "label": "Allow_All_UDP_Outbound"}
                  ]' \
                  --rules.inbound_policy="DROP" \
                  --rules.outbound_policy="ACCEPT" \
                  --json)
                CREATE_STATUS=$?
                set -e

                if [[ $CREATE_STATUS -ne 0 || -z "$CREATE_OUTPUT" ]]; then
                    log "‚ùå Failed to create firewall $FIREWALL_LABEL. Sleeping indefinitely to avoid crashloop."
                    sleep infinity
                fi

                FIREWALL_ID=$(echo "$CREATE_OUTPUT" | jq -r '.[0].id')
                log "‚úÖ Firewall created with ID $FIREWALL_ID"
            else
                log "‚úÖ Firewall $FIREWALL_LABEL already exists with ID $FIREWALL_ID"
            fi

            # Check if any firewall is already attached to this Linode
            log "üîç Verifying if Linode ID $LINODE_ID already has any firewall attached..."
            FIREWALLS_WITH_ENTITIES=$(linode-cli firewalls list --json | jq -r '.[] | select(.entities != null) | @base64')
            for fw in $FIREWALLS_WITH_ENTITIES; do
                _jq() { echo "$fw" | base64 --decode | jq -r "$1"; }
                FW_ID=$(_jq '.id')
                ENTITY_IDS=$(linode-cli firewalls view "$FW_ID" --json | jq -r '.[0].entities[]?.id')
                for id in $ENTITY_IDS; do
                    if [[ "$id" == "$LINODE_ID" ]]; then
                        log "‚ö†Ô∏è Linode ID $LINODE_ID already has a firewall attached (Firewall ID: $FW_ID). Skipping attachment."
                        return 0
                    fi
                done
            done

            log "üîó Attaching firewall $FIREWALL_LABEL to Linode instance $LINODE_ID..."
            set +e
            linode-cli firewalls device-create "$FIREWALL_ID" --type linode --id "$LINODE_ID"
            ATTACH_STATUS=$?
            set -e

            if [[ $ATTACH_STATUS -eq 0 ]]; then
                # Wait for firewall to be fully attached before proceeding
                ATTACH_WAIT_RETRIES=10
                ATTACH_WAIT_DELAY=5
                for i in $(seq 1 $ATTACH_WAIT_RETRIES); do
                    FIREWALL_DEVICE_STATUS=$(linode-cli firewalls devices-list "$FIREWALL_ID" --json | jq -r ".[] | select(.id == $LINODE_ID) | .status")
                    if [[ "$FIREWALL_DEVICE_STATUS" == "enabled" ]]; then
                        log "‚úÖ Firewall attachment confirmed (status: enabled)"
                        break
                    else
                        log "‚è≥ Waiting for firewall to attach (attempt $i/$ATTACH_WAIT_RETRIES)..."
                        sleep "$ATTACH_WAIT_DELAY"
                    fi
                done
                log "‚úÖ Firewall successfully attached to Linode ID $LINODE_ID"
                log "üõ°Ô∏è Firewall ENABLED ‚Äì Firewall '$FIREWALL_LABEL' (ID: $FIREWALL_ID) successfully created/attached to instance."
                log "‚úÖ Firewall attachment complete. Continuing to finalize script execution..."
            else
                log "‚ùå Failed to attach firewall to Linode ID $LINODE_ID. Sleeping indefinitely to avoid container restart loop."
                sleep infinity
            fi
        }
        
        # === Discover Node IP and Name ===
        # Retrieve the IP address of eth0 (assumed to be the main interface)
        log "üåê Fetching NODE IP of the instance..."
        NODE_IP=$(ip addr show eth0 | grep -v "eth0:[0-9]" | grep -w inet | awk {'print $2'}|awk -F'/' {'print $1'})
        
        log "üåê Node IP: $NODE_IP"
        
        # Query Kubernetes to find the node name associated with this IP
        log "üåê Fetching NODE NAME of the instance..."
        NODE_NAME=$(kubectl get nodes -o json | jq -r '.items[] | select(.status.addresses[]?.address == "'"$NODE_IP"'") | .metadata.name')
        
        log "üåê Node Name: $NODE_NAME"
        
        # === Fetch Public IP of the Node ===
        # This fetches the public IP associated with the node from the Kubernetes API
        log "üåê Fetching Public IP of the instance..."
        PUBLIC_IP=$(kubectl get node $NODE_NAME -o jsonpath='{.status.addresses[?(@.type=="ExternalIP")].address}' | awk {'print $1'})
        log "üåê Public IP of the Node: $PUBLIC_IP"
        
        export LINODE_CLI_CONFIG="/root/.linode-cli/linode-cli"
        
        # === Discover Linode ID and Configuration ID ===
        # Linode API calls to find the instance ID and its configuration ID
        LINODE_ID=$(linode-cli linodes list --json | jq -r ".[] | select(.ipv4[] | contains(\"$PUBLIC_IP\")) | .id")
        CONFIG_ID=$(linode-cli linodes configs-list $LINODE_ID --json | jq -r '.[0].id')
        
        # If either the Linode ID or Config ID is not found, retry after 60 seconds
        if [ -z "$LINODE_ID" ] || [ -z "$CONFIG_ID" ]; then
            log "‚ùå Failed to retrieve Linode ID or Config ID. Sleeping for 60 seconds and retrying..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        log "‚úÖ Linode ID: $LINODE_ID, Config ID: $CONFIG_ID"
        
        # === Main Logic ===
        log "üîé Checking if VLAN is already attached to Linode instance $LINODE_ID..."
        if is_vlan_attached; then
            log "‚úÖ VLAN is already attached. Skipping VLAN configuration and directly pushing the route."
            push_route
            create_and_attach_firewall
            log "üõå VLAN configuration complete. Sleeping indefinitely..."
            sleep infinity
        fi
        
        # === VLAN Configuration Logic with Retry ===
        log "‚ùå VLAN is not attached. Proceeding with VLAN configuration..."
        MAX_RETRIES=5
        RETRY_COUNT=0
        SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            log "üîÑ Attempting to allocate IP address... (Attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
            
            set +e
            IP_ADDRESS1=$(/tmp/03-script-ip-allocate.sh $SUBNET)
            STATUS=$?
            set -e
        
            if [ $STATUS -eq 0 ]; then
                IP_ADDRESS=$(echo $IP_ADDRESS1 | awk {'print $NF'})
                if [ -n "$IP_ADDRESS" ]; then
                    log "‚úÖ Allocated IP address: $IP_ADDRESS"
                    SUCCESS=true
                    break
                else
                    log "‚ö†Ô∏è  No IP address found in response. Retrying..."
                fi
            else
                log "‚ùå IP allocation script failed. Retrying..."
            fi
        
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 5
        done
        
        if [ "$SUCCESS" = false ]; then
            log "‚ùå IP allocation failed after $MAX_RETRIES attempts. Retrying in 60 seconds..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        # === Build VLAN JSON ===
        log "‚öôÔ∏è  Building VLAN attachment JSON..."
        INTERFACES_JSON=$(jq -n --arg ip "$IP_ADDRESS" --arg vlan "$VLAN_LABEL" '
            [
              { "type": "public", "purpose": "public" },
              { "type": "vlan", "label": $vlan, "purpose": "vlan", "ipam_address": $ip }
            ]
        ')
        echo $INTERFACES_JSON | jq .
        
        # === Attach the VLAN interface ===
        log "‚öôÔ∏è  Attaching VLAN interface to Linode instance..."
        linode-cli linodes config-update "$LINODE_ID" "$CONFIG_ID" --interfaces "$INTERFACES_JSON" --label "Boot Config"
        
        # === Check Success ===
        if is_vlan_attached; then
            log "‚úÖ VLAN successfully attached."
            create_and_attach_firewall
            touch /tmp/rebooting
            log "Rebooting Linode after firewall confirmed attached..."
            linode-cli linodes reboot "$LINODE_ID"
            sleep infinity
        else
            log "‚ùå VLAN configuration failed. Retrying in 60 seconds..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        # === Cleanup Logic ===
        cleanup() {
            if [ -f "/tmp/rebooting" ]; then
                log "Skipping IP release due to planned reboot."
                rm -rfv /tmp/rebooting
            else
                log "Releasing IP address $IP_ADDRESS..."
                /tmp/04-script-ip-release.sh "$IP_ADDRESS"
                log "IP address $IP_ADDRESS released."
            fi
        }
        trap cleanup EXIT
        
        log "‚úÖ VLAN Attachment completed successfully."
        log "üåê Instance $LINODE_ID is now connected to VLAN $VLAN_LABEL with IP $IP_ADDRESS."
        # The following block is removed because firewall success is now logged in create_and_attach_firewall:
        # if [[ "$ENABLE_FIREWALL" == "true" ]]; then
        #     if [[ -n "$FIREWALL_ID" ]]; then
        #         log "üõ°Ô∏è Firewall ENABLED ‚Äì Firewall '$FIREWALL_LABEL' (ID: $FIREWALL_ID) successfully created/attached to instance."
        #     else
        #         log "‚ö†Ô∏è Firewall ENABLED ‚Äì but Firewall ID not set. Check previous logs for errors during creation or attachment."
        #     fi
        # else
        #     log "‚ÑπÔ∏è Firewall DISABLED ‚Äì Skipping firewall creation and attachment as ENABLE_FIREWALL is set to false."
        # fi
        log "üü¢ VLAN and Firewall configuration steps completed successfully."
        log "üõå Script execution complete. Sleeping indefinitely..."
        sleep infinity
  03-script-ip-allocate.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP allocation
        API_ENDPOINT="http://vlan-leader-service.kube-system.svc.cluster.local:8080/allocate"
        SUBNET=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$SUBNET" ]; then
            error "No subnet provided for IP allocation."
        fi
        
        log "Requesting IP from API at $API_ENDPOINT for Subnet: $SUBNET..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT \
            -H "Content-Type: application/json" \
            -d "{\"subnet\": \"$SUBNET\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            ALLOCATED_IP=$(echo $RESPONSE_BODY | jq -r '.allocated_ip')
            log "Successfully allocated IP: $ALLOCATED_IP"
            echo $ALLOCATED_IP
        else
            case $HTTP_CODE in
                404)
                    error "API Endpoint not found. Service 'vlan-leader-service' may not be running in namespace 'kube-system'."
                    ;;
                500)
                    error "No IP addresses available in the provided subnet."
                    ;;
                400)
                    error "Bad request. The subnet format is incorrect."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi
        
  04-script-ip-release.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP release
        API_ENDPOINT="http://vlan-leader-service.kube-system.svc.cluster.local:8080/release"
        IP_ADDRESS=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$IP_ADDRESS" ]; then
            error "No IP address provided for release."
        fi
        
        log "Requesting IP release from API at $API_ENDPOINT for IP: $IP_ADDRESS..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT -H "Content-Type: application/json" -d "{\"ip_address\": \"$IP_ADDRESS\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            log "Successfully released IP: $IP_ADDRESS"
            echo $IP_ADDRESS
        else
            case $HTTP_CODE in
                404)
                    error "IP address $IP_ADDRESS not found in the allocation list."
                    ;;
                400)
                    error "Bad request. Possibly malformed JSON or missing IP address."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi
        
  05-script-ip-list-initialize.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # --- Define Color Codes ---
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[1;34m'
        NC='\033[0m' # No Color
        
        LINODE_TOKEN="${LINODE_TOKEN}"
        #LINODE_TOKEN=`grep token /root/.linode-cli/linode-cli | awk -F'= ' {'print $2'}`
        OUTPUT_FILE="/mnt/vlan-ip/vlan-ip-list.txt"
        PAGE_SIZE=100
        CURRENT_PAGE=1
        TOTAL_PAGES=1
        MAX_RETRIES=3
        BACKOFF_BASE=2
        INITIAL_JOBS=5
        MAX_JOBS=20
        
        # === Environment Variables ===
        # File path for IP list storage
        IP_FILE_PATH=$OUTPUT_FILE
        
        # Subnet is passed as the first argument
        SUBNET=$1
        REGION=$2
        
        # === Validate Subnet is Provided ===
        # If the subnet is not passed as an argument, exit with an error
        if [ -z "$SUBNET" ]; then
            log "[ERROR] No subnet provided for initialization."
            exit 1
        fi
        
        # === Validate if Region is Provided ===
        # If the region is not passed as an argument, exit with an error
        if [ -z "$REGION" ]; then
            log "[ERROR] No REGION provided for initialization."
            exit 1
        fi
        
        # === Function to Log Events ===
        # This function logs events with timestamps for better traceability
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        log "üîÑ Starting IP List Initialization..."
        
        # === Check if the file already has data ===
        if [ -f "$IP_FILE_PATH" ] && [ -s "$IP_FILE_PATH" ]; then
            log "IP List file already initialized. Skipping initialization."
            exit 0
        fi
        
        # Initialize the files if not present
        if [ ! -f "$IP_FILE_PATH" ]; then
            log "Creating IP list file at $IP_FILE_PATH"
            touch $IP_FILE_PATH
        fi
        
        
        log "üåê Subnet provided for initialization: $SUBNET"
        
        # --- Retry Logic Wrapper with Intelligent Backoff and 404 Handling ---
        retry_curl() {
            local URL=$1
            local OUTPUT=$2
            local RETRY_COUNT=0
            local BACKOFF=1
            local SUCCESS=false
        
            while [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
                echo -e "${BLUE}üåê Attempting API call: $URL (Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)${NC}"
                
                START_TIME=$(date +%s)  # Start timer
        
                if [[ "$URL" == *"/linode/instances/"*"/configs" ]]; then
                    HTTP_CODE=$(curl -s -w "%{http_code}" -H "Authorization: Bearer $LINODE_TOKEN" \
                                "$URL" -o "$OUTPUT")
                else
                    HTTP_CODE=$(curl -s -w "%{http_code}" -H "Authorization: Bearer $LINODE_TOKEN" \
                                -H 'X-Filter: {"region": "'$REGION'"}' \
                                "$URL" -o "$OUTPUT")
                fi
        
                END_TIME=$(date +%s)    # End timer
                DURATION=$((END_TIME - START_TIME))
                echo "$URL | $DURATION ms" >> latency-log.txt
        
                case "$HTTP_CODE" in
                    200)
                        if [ -s "$OUTPUT" ]; then
                            SUCCESS=true
                            echo -e "${GREEN}‚úÖ API call successful ($DURATION ms): $URL${NC}"
                            break
                        fi
                        ;;
                    404)
                        echo -e "${RED}‚ùå [404] Resource not found: $URL${NC}" | tee -a error-log.txt
                        echo -e "${YELLOW}   ‚û°Ô∏è  Skipping further retries for this resource.${NC}"
                        return 1
                        ;;
                    429)
                        echo -e "${YELLOW}‚ö†Ô∏è Rate limit hit. Backing off for $BACKOFF seconds...${NC}"
                        sleep "$BACKOFF"
                        BACKOFF=$((BACKOFF * BACKOFF_BASE))
                        ;;
                    *)
                        echo -e "${RED}‚ö†Ô∏è API call failed with HTTP Code $HTTP_CODE, retrying in $BACKOFF seconds...${NC}"
                        sleep "$BACKOFF"
                        BACKOFF=$((BACKOFF * BACKOFF_BASE))
                        ;;
                esac
        
                ((RETRY_COUNT++))
            done
        
            if [ "$SUCCESS" = false ] && [ "$HTTP_CODE" != "404" ]; then
                echo -e "${RED}‚ùå API call failed after $MAX_RETRIES attempts: $URL${NC}" | tee -a error-log.txt
            fi
        }
        
        # --- Step 1: Paginated Fetch for All Linode IDs in the region with X-Filter ---
        echo -e "${BLUE}üåê Fetching Linode IDs in region $REGION with Pagination...${NC}"
        while [ "$CURRENT_PAGE" -le "$TOTAL_PAGES" ]; do
            echo -e "${BLUE}   ‚û°Ô∏è  Fetching page $CURRENT_PAGE of $TOTAL_PAGES${NC}"
            
            URL="https://api.linode.com/v4/linode/instances?page=$CURRENT_PAGE&page_size=$PAGE_SIZE"
            TEMP_RESPONSE=$(mktemp)
            
            # Fetch paginated data with retry logic
            retry_curl "$URL" "$TEMP_RESPONSE"
            
            # Fetch Linode IDs and append to file
            cat "$TEMP_RESPONSE" | jq -r '.data[] | .id' >> linodes.txt
            
            # Get pagination info
            TOTAL_PAGES=$(cat "$TEMP_RESPONSE" | jq -r '.pages')
            CURRENT_PAGE=$((CURRENT_PAGE + 1))
            rm -f "$TEMP_RESPONSE"
        done
        
        # --- Step 2: Count the number of Linode IDs and adjust MAX_JOBS ---
        TOTAL_LINODES=$(wc -l < linodes.txt)
        if [ "$TOTAL_LINODES" -lt "$INITIAL_JOBS" ]; then
            MAX_JOBS="$TOTAL_LINODES"
        else
            # --- Adjust parallel jobs based on latency ---
            AVG_LATENCY=$(awk '{sum+=$3} END {print int(sum/NR)}' latency-log.txt)
            
            if [ "$AVG_LATENCY" -lt 200 ]; then
                MAX_JOBS=20
            elif [ "$AVG_LATENCY" -lt 500 ]; then
                MAX_JOBS=10
            else
                MAX_JOBS=5
            fi
        fi
        
        echo -e "${GREEN}üîé Found $TOTAL_LINODES Linode IDs. Adjusting parallel jobs to $MAX_JOBS (Avg Latency: $AVG_LATENCY ms)${NC}"
        
        # --- Step 3: Function to fetch VLAN IPs for a single Linode ---
        fetch_vlan_ips() {
            local LID=$1
            local TEMP_FILE=$(mktemp)
            local TEMP_RESPONSE=$(mktemp)
            echo -e "${GREEN}üîé Checking Linode ID: $LID${NC}"
        
            # Fetch configurations for the Linode with retry logic and X-Filter for interfaces
            URL="https://api.linode.com/v4/linode/instances/$LID/configs"
            retry_curl "$URL" "$TEMP_RESPONSE"
        
            if [ $? -ne 0 ]; then
                echo -e "${RED}‚ùå [ERROR] Failed to fetch configs for Linode ID $LID${NC}" | tee -a error-log.txt
                return 1
            fi
        
            # Extract VLAN IPs directly (No additional curl calls)
            VLAN_IPS=$(cat "$TEMP_RESPONSE" | jq -r ".data[].interfaces[] | select(.purpose == \"vlan\") | .ipam_address")
        
            # Write to the temp file and success log
            if [ -n "$VLAN_IPS" ]; then
                echo "$VLAN_IPS" >> "$TEMP_FILE"
                echo -e "${GREEN}‚úÖ [SUCCESS] VLAN IPs found for Linode ID $LID - $VLAN_IPS${NC}" | tee -a success-log.txt
            else
                echo -e "${YELLOW}‚ö†Ô∏è [INFO] No VLAN IPs found for Linode ID $LID${NC}" | tee -a success-log.txt
            fi
        
            # Append temp file to final output (atomic operation)
            if [ -s "$TEMP_FILE" ]; then
                cat "$TEMP_FILE" >> "$OUTPUT_FILE"
            fi
        
            rm -f "$TEMP_FILE" "$TEMP_RESPONSE"
        }
        
        # === Calculate IP addresses without ipcalc ===
        NETWORK_PREFIX=$(echo $SUBNET | cut -d'/' -f2)
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo $SUBNET | cut -d'/' -f1)"
        
        # Extract the IP segments correctly
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo "$SUBNET" | cut -d'/' -f1)"
        
        # Sanity check
        if [ -z "$i1" ] || [ -z "$i2" ] || [ -z "$i3" ]; then
            echo -e "${RED}[ERROR] Subnet parsing failed. Please check the subnet format.${NC}"
            exit 1
        fi
        
        # Network IP (x.x.x.0)
        NETWORK_IP="${i1}.${i2}.${i3}.0/$NETWORK_PREFIX"
        
        # First usable IP (x.x.x.1)
        FIRST_IP="${i1}.${i2}.${i3}.1/$NETWORK_PREFIX"
        
        # Broadcast IP (x.x.x.255)
        BROADCAST_IP="${i1}.${i2}.${i3}.255/$NETWORK_PREFIX"
        
        # Reserved IPs Array
        RESERVED_IPS=("$NETWORK_IP" "$FIRST_IP" "$BROADCAST_IP")
        
        log "Reserved IPs for subnet $SUBNET: ${RESERVED_IPS[*]}"
        
        # Adding reserved IPs to $IP_FILE_PATH files
        log "Adding reserved IPs to the allocation list for reserving it..."
        for ip in "${RESERVED_IPS[@]}"; do
            if ! grep -q "^$ip$" "$IP_FILE_PATH"; then
                echo "$ip" >> "$IP_FILE_PATH"
                log "Reserved IP added to list: $ip"
            fi
        done
        
        # --- Export function and variables for parallel ---
        export -f fetch_vlan_ips retry_curl
        export LINODE_TOKEN OUTPUT_FILE MAX_RETRIES
        
        # --- Step 4: Parallel Processing of Linode IDs ---
        echo -e "${BLUE}üåê Fetching VLAN IPs from configurations in parallel...${NC}"
        cat linodes.txt | parallel -j "$MAX_JOBS" fetch_vlan_ips {}
        
        # --- Cleanup ---
        rm -f linodes.txt
        
        # --- Final Output ---
        echo -e "${GREEN}‚úÖ VLAN IP Initialization Complete. IPs saved to $OUTPUT_FILE${NC}"
        cat "$OUTPUT_FILE"
        
        log "‚úÖ IP List Initialization Complete. Saved to $IP_FILE_PATH"
        
  06-rest-api.py: |
        # Import necessary libraries for web server, concurrency, networking, and file handling
        from flask import Flask, jsonify, request
        from flask_cors import CORS
        import os
        import ipaddress
        import json
        import sys
        import time
        from filelock import FileLock
        import requests
        from concurrent.futures import ThreadPoolExecutor
        from datetime import datetime, timedelta
        import asyncio
        import aiohttp
        import psutil
        import signal
        import configparser
        
        # Initialize Flask application instance
        app = Flask(__name__)
        # Enable Cross-Origin Resource Sharing (CORS) for this Flask app
        CORS(app)
        
        # Define the path to the IP address allocation list file
        IP_FILE_PATH = "/mnt/vlan-ip/vlan-ip-list.txt"
        
        # Define the log file path for logging allocation and healthcheck events
        LOG_FILE = "/tmp/allocate-ip.log"
        
        # Maximum number of log lines to retain in the log file
        MAX_LOG_LINES = 1000
        
        # Maximum backoff time in seconds for retry loops (e.g., API retries)
        MAX_BACKOFF = 60
        
        # Default region list used if API-based region fetch fails
        FALLBACK_REGIONS = ['us-east', 'us-west', 'in-maa', 'eu-west', 'eu-central']
        
        # Cache dictionary to store VLAN IPs with a TTL for performance
        VLAN_IP_CACHE = {
            "ips": None,
            "timestamp": None,
            "ttl_seconds": int(os.getenv("CACHE_TTL_SECONDS", 60))
        }
        
        # Cache to validate region metadata to reduce repetitive API calls
        REGION_CACHE = {"valid": False, "timestamp": None, "ttl_seconds": 3600}
        
        
        # Signal handler to gracefully shutdown the app when terminated
        def graceful_exit(signalnum, frame):
            log(f"[INFO] Received signal {signalnum}. Shutting down gracefully...")
            sys.exit(0)
        
        
        # Register signal handlers for SIGTERM and SIGINT (Ctrl+C)
        signal.signal(signal.SIGTERM, graceful_exit)
        
        # Register signal handlers for SIGTERM and SIGINT (Ctrl+C)
        signal.signal(signal.SIGINT, graceful_exit)
        
        
        # Async region fetching
        async def fetch_regions_async(headers, retries=3, backoff=2):
            async with aiohttp.ClientSession() as session:
                for attempt in range(retries):
                    try:
                        async with session.get("https://api.linode.com/v4/regions", headers=headers, timeout=5) as response:
                            if response.status == 200:
                                data = await response.json()
                                return [r["id"] for r in data.get("data", [])]
                            elif response.status == 429:
                                wait_time = int(response.headers.get('Retry-After', 5))
                                log(f"[WARN] Rate limited (429). Retrying after {wait_time} seconds...")
                                await asyncio.sleep(wait_time)
                            else:
                                log(f"[WARN] API call failed with status {response.status}. Retrying in {backoff} seconds...")
                                await asyncio.sleep(backoff)
                                # Maximum backoff time in seconds for retry loops (e.g., API retries)
                                backoff = min(backoff * 2, MAX_BACKOFF)
                    except aiohttp.ClientError as e:
                        log(f"[ERROR] Network error during async API call: {str(e)}. Retrying in {backoff} seconds...")
                        await asyncio.sleep(backoff)
                        # Maximum backoff time in seconds for retry loops (e.g., API retries)
                        backoff = min(backoff * 2, MAX_BACKOFF)
                log("[ERROR] Failed to fetch regions after retries")
                return None
        
        
        async def update_regions_cache():
            linode_token = fetch_linode_token()
            if linode_token:
                headers = {"Authorization": f"Bearer {linode_token}"}
                regions = await fetch_regions_async(headers)
                if regions:
                    # Default region list used if API-based region fetch fails
                    global FALLBACK_REGIONS
                    # Default region list used if API-based region fetch fails
                    FALLBACK_REGIONS = regions
                    # Default region list used if API-based region fetch fails
                    log(f"[INFO] Updated fallback regions: {FALLBACK_REGIONS}")
        
        
        async def schedule_region_updates():
            while True:
                await update_regions_cache()
                await asyncio.sleep(600)
        
        
        def validate_environment():
            errors = []
            REGION = os.getenv("REGION")
            if not REGION:
                errors.append("REGION environment variable not set")
            else:
                linode_token = fetch_linode_token()
                # Default region list used if API-based region fetch fails
                valid_regions = FALLBACK_REGIONS
                if linode_token:
                    headers = {"Authorization": f"Bearer {linode_token}"}
                    response = api_request_with_retry("https://api.linode.com/v4/regions", headers)
                    if response:
                        valid_regions = [r["id"] for r in response.get("data", [])]
                        log(f"[DEBUG] Valid Linode regions: {valid_regions}")
                    else:
                        asyncio.create_task(schedule_region_updates())
                if REGION not in valid_regions:
                    errors.append(f"Invalid region: {REGION}. Valid regions: {valid_regions}")
        
            # Define the path to the IP address allocation list file
            ip_dir = os.path.dirname(IP_FILE_PATH)
            if not os.access(ip_dir, os.W_OK):
                errors.append(f"No write permission for directory {ip_dir}")
        
            # Define the log file path for logging allocation and healthcheck events
            log_dir = os.path.dirname(LOG_FILE)
            if not os.access(log_dir, os.W_OK):
                errors.append(f"No write permission for directory {log_dir}")
        
            try:
                requests.get("https://api.linode.com/v4/regions", timeout=5)
            except requests.RequestException:
                errors.append("No network connectivity to Linode API")
        
            if errors:
                for error in errors:
                    log(f"[ERROR] {error}")
                sys.exit(1)
        
        
        def log(message):
            print(message)
            sys.stdout.flush()
            # Define the log file path for logging allocation and healthcheck events
            with FileLock(LOG_FILE + ".lock"):
                try:
                    lines = []
                    # Define the log file path for logging allocation and healthcheck events
                    if os.path.exists(LOG_FILE):
                        # Define the log file path for logging allocation and healthcheck events
                        with open(LOG_FILE, "r") as f:
                            lines = f.read().splitlines()
                    lines.append(message)
                    # Maximum number of log lines to retain in the log file
                    lines = lines[-MAX_LOG_LINES:]
                    # Define the log file path for logging allocation and healthcheck events
                    with open(LOG_FILE, "w") as f:
                        f.write("\n".join(lines) + "\n")
                except Exception as e:
                    print(f"[ERROR] Failed to write to log file: {str(e)}")
        
        
        def api_request_with_retry(url, headers, retries=3, backoff=2):
            for attempt in range(retries):
                try:
                    response = requests.get(url, headers=headers, timeout=5)
                    if response.status_code == 200:
                        try:
                            return response.json()
                        except ValueError as e:
                            log(f"[ERROR] Invalid JSON response: {response.text}")
                            return None
                    elif response.status_code == 429:
                        wait_time = int(response.headers.get('Retry-After', 5))
                        log(f"[WARN] Rate limited (429). Retrying after {wait_time} seconds...")
                        time.sleep(wait_time)
                    elif response.status_code >= 500:
                        log(f"[WARN] Server error {response.status_code}. Retrying in {backoff} seconds...")
                        time.sleep(backoff)
                        # Maximum backoff time in seconds for retry loops (e.g., API retries)
                        backoff = min(backoff * 2, MAX_BACKOFF)
                    else:
                        log(f"[WARN] API call failed with status {response.status_code}. Retrying in {backoff} seconds...")
                        time.sleep(backoff)
                        # Maximum backoff time in seconds for retry loops (e.g., API retries)
                        backoff = min(backoff * 2, MAX_BACKOFF)
                except requests.ConnectionError as e:
                    log(f"[ERROR] Connection error during API call: {str(e)}. Retrying in {backoff} seconds...")
                    time.sleep(backoff)
                    # Maximum backoff time in seconds for retry loops (e.g., API retries)
                    backoff = min(backoff * 2, MAX_BACKOFF)
                except requests.Timeout as e:
                    log(f"[ERROR] Timeout during API call: {str(e)}. Retrying in {backoff} seconds...")
                    time.sleep(backoff)
                    # Maximum backoff time in seconds for retry loops (e.g., API retries)
                    backoff = min(backoff * 2, MAX_BACKOFF)
                except requests.RequestException as e:
                    log(f"[ERROR] Other network error during API call: {str(e)}. Retrying in {backoff} seconds...")
                    time.sleep(backoff)
                    # Maximum backoff time in seconds for retry loops (e.g., API retries)
                    backoff = min(backoff * 2, MAX_BACKOFF)
            log(f"[ERROR] API call failed after {retries} attempts.")
            return None
        
        
        def fetch_linode_token(config_file='/root/.linode-cli/linode-cli'):
            """
            Read the Linode CLI config file and extract the token for the default user.
        
            Args:
                config_file (str): Path to the Linode CLI configuration file
        
            Returns:
                str: The token value, or None if not found
            """
            # Check if the file exists
            if not os.path.exists(config_file):
                print(f"Error: Configuration file {config_file} not found")
                return None
        
            # Initialize config parser
            config = configparser.ConfigParser()
        
            try:
                # Read the configuration file
                config.read(config_file)
        
                # Get the default user from the [DEFAULT] section
                if 'DEFAULT' not in config or 'default-user' not in config['DEFAULT']:
                    print(f"Error: No default-user found in {config_file}")
                    return None
        
                default_user = config['DEFAULT']['default-user']
        
                # Check if the user section exists
                if default_user not in config:
                    print(f"Error: User profile '{default_user}' not found in {config_file}")
                    return None
        
                # Extract the token
                token = config[default_user].get('token')
                if not token:
                    print(f"Error: No token found for user '{default_user}' in {config_file}")
                    return None
        
                return token
        
            except Exception as e:
                print(f"Error reading configuration file: {str(e)}")
                return None
        
        
        def remove_duplicates():
            with FileLock(IP_FILE_PATH + ".lock"):
                try:
                    with open(IP_FILE_PATH, 'r') as f:
                        unique_lines = set(f.read().splitlines())
                    with open(IP_FILE_PATH, 'w') as f:
                        f.write("\n".join(unique_lines) + "\n")
                    log(f"[INFO] Removed duplicates from IP file. Unique IPs: {len(unique_lines)}")
                except FileNotFoundError:
                    log(f"[WARNING] IP file {IP_FILE_PATH} not found during deduplication")
        
        
        def fetch_assigned_ips():
            if (
                    VLAN_IP_CACHE["ips"] is not None
                    and VLAN_IP_CACHE["timestamp"] is not None
                    and (datetime.now() - VLAN_IP_CACHE["timestamp"]).total_seconds() < VLAN_IP_CACHE["ttl_seconds"]
            ):
                log("[INFO] Using cached VLAN IPs")
                return VLAN_IP_CACHE["ips"]
        
            LINODE_TOKEN = fetch_linode_token()
            REGION = os.getenv("REGION")
        
            if not REGION:
                log("[ERROR] REGION environment variable not set")
                raise EnvironmentError("REGION environment variable not set")
        
            if not LINODE_TOKEN:
                log("[ERROR] Missing Linode Token")
                return None
        
            headers = {"Authorization": f"Bearer {LINODE_TOKEN}"}
            log(f"[DEBUG] Fetching VLAN IPs for region: {REGION}")
        
            url = "https://api.linode.com/v4/linode/instances"
            instances = api_request_with_retry(url, headers={"Authorization": f"Bearer {LINODE_TOKEN}",
                                                             "X-Filter": f'{{"region": "{REGION}"}}'})
        
            if not instances:
                log("[ERROR] Failed to fetch Linode instances")
                return None
        
            linode_ids = [str(l["id"]) for l in instances.get("data", [])]
            log(f"[DEBUG] Linode IDs fetched: {linode_ids}")
        
            vlan_ips = []
        
            def fetch_configs(linode_id):
                try:
                    log(f"[DEBUG] Fetching VLAN IPs for Linode ID: {linode_id}")
                    config_url = f"https://api.linode.com/v4/linode/instances/{linode_id}/configs"
                    configs = api_request_with_retry(config_url, headers)
                    if not configs:
                        log(f"[ERROR] Failed to fetch configurations for Linode ID {linode_id}")
                        return []
                    linode_vlan_ips = []
                    for config in configs.get("data", []):
                        for iface in config.get("interfaces", []):
                            if iface.get("purpose") == "vlan":
                                ip_address = iface.get("ipam_address")
                                if ip_address:
                                    linode_vlan_ips.append(ip_address)
                                    log(f"[DEBUG] Found VLAN IP: {ip_address}")
                    return linode_vlan_ips
                except Exception as e:
                    log(f"[ERROR] Exception in fetch_configs for Linode ID {linode_id}: {str(e)}")
                    return []
        
            max_workers = int(os.getenv("MAX_WORKERS", 20))
            max_workers = min(max_workers, max(1, len(linode_ids)))
            if max_workers == 1 and len(linode_ids) > 1:
                log(f"[WARN] Only 1 worker thread available with {len(linode_ids)} Linode instances. Possible API rate limiting.")
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                results = executor.map(fetch_configs, linode_ids)
                for result in results:
                    vlan_ips.extend(result)
        
            log(f"[DEBUG] All VLAN IPs in region {REGION}: {vlan_ips}")
        
            VLAN_IP_CACHE["ips"] = vlan_ips
            VLAN_IP_CACHE["timestamp"] = datetime.now()
        
            return vlan_ips
        
        
        def safe_update_ip_list(ips):
            with FileLock(IP_FILE_PATH + ".lock"):
                with open(IP_FILE_PATH, 'a') as f:
                    f.write("\n".join(str(ip) for ip in ips) + "\n")
            log(f"[INFO] Successfully wrote {len(ips)} IPs to file: {ips}")
        
        
        def system_health_check():
            load_avg = os.getloadavg()
            mem = psutil.virtual_memory()
            mem_info = f"Total: {mem.total / (1024 ** 2):.2f} MB, Used: {mem.used / (1024 ** 2):.2f} MB, Free: {mem.free / (1024 ** 2):.2f} MB"
            log(f"[INFO] System Load Average: {load_avg}")
            log(f"[INFO] Memory Information: {mem_info}")
            if load_avg[0] > os.cpu_count() * 2:
                log("[WARN] High system load detected")
                return False
            if mem.percent > 90:
                log("[WARN] High memory usage detected")
                return False
            return True
        
        
        # =======================
        # üü¢ Allocate IP Endpoint Sandip
        # =======================
        @app.route('/allocate', methods=['POST'])
        def allocate_ip():
            try:
                subnet = request.json.get('subnet')
                if not subnet:
                    log("[ERROR] Subnet not provided")
                    return jsonify({"error": "Subnet not provided"}), 400
        
                REGION = os.getenv("REGION")
                if not REGION:
                    log("[ERROR] Region not provided")
                    return jsonify({"error": "Region not provided"}), 400
        
                log(f"[DEBUG] Subnet: {subnet}, Region: {REGION}")
        
                try:
                    ip_net = ipaddress.ip_network(subnet, strict=False)
                    cidr_suffix = f"/{ip_net.prefixlen}"
                except ValueError:
                    log("[ERROR] Invalid subnet format")
                    return jsonify({"error": "Invalid subnet format"}), 400
        
                remove_duplicates()
                fetched_ips = fetch_assigned_ips()
                if not fetched_ips:
                    fetched_ips = []
                    log("[WARN] No VLAN IPs were returned from Linode API. Proceeding with empty list.")
                linode_ips = fetched_ips
        
                log(f"[DEBUG] Assigned VLAN IPs found in Linode: {linode_ips}")
        
                ip_list = []
                try:
                    with FileLock(IP_FILE_PATH + ".lock"):
                        with open(IP_FILE_PATH, 'r') as f:
                            ip_list = [line.strip() for line in f.read().splitlines() if line.strip()]
                    log(f"[DEBUG] Local IP List from file: {ip_list}")
                except FileNotFoundError:
                    log(f"[WARNING] IP file {IP_FILE_PATH} not found, treating as empty")
                    ip_list = []
        
                local_ip_set = set(ip_list)
                linode_ip_set = set(linode_ips) if linode_ips else set()
        
                new_linode_ips = linode_ip_set - local_ip_set
                if new_linode_ips:
                    try:
                        safe_update_ip_list(list(new_linode_ips))
                        local_ip_set.update(new_linode_ips)
                        log(f"[DEBUG] Local IP List after syncing Linode IPs: {list(local_ip_set)}")
                    except Exception as e:
                        log(f"[ERROR] Failed to sync Linode IPs: {str(e)}")
                        return jsonify({"error": f"Failed to sync Linode IPs: {str(e)}"}), 500
        
                log(f"[DEBUG] --- Begin IP Scan ---")
        
                attempted_ips = []
                skipped_local = 0
                skipped_linode = 0
        
                for ip in ip_net.hosts():
                    candidate_ip = f"{ip}{cidr_suffix}"
                    attempted_ips.append(candidate_ip)
                    log(f"[DEBUG] Checking Candidate IP: {candidate_ip}")
        
                    if candidate_ip in local_ip_set:
                        log(f"[INFO] Skipping IP (Already allocated locally): {candidate_ip}")
                        skipped_local += 1
                        continue
                    if candidate_ip in linode_ip_set:
                        log(f"[INFO] Skipping IP (Already allocated in Linode): {candidate_ip}")
                        skipped_linode += 1
                        continue
        
                    try:
                        safe_update_ip_list([candidate_ip])
                        log(f"[SUCCESS] Allocated IP: {candidate_ip}")
                        return jsonify({"allocated_ip": candidate_ip}), 200
                    except OSError as e:
                        log(f"[ERROR] Failed to allocate IP {candidate_ip}: {str(e)}")
                        return jsonify({"error": f"Failed to allocate IP: {str(e)}"}), 500
        
                error_msg = (
                    f"No IPs available in subnet {subnet}. "
                    f"Attempted {len(attempted_ips)} IPs: {skipped_local} already allocated locally, "
                    f"{skipped_linode} already allocated in Linode."
                )
                log(f"[ERROR] {error_msg}")
                return jsonify({"error": error_msg}), 400
        
            except ValueError as e:
                log(f"[ERROR] Invalid input in /allocate endpoint: {str(e)}")
                return jsonify({"error": f"Invalid input: {str(e)}"}), 400
            except requests.RequestException as e:
                log(f"[ERROR] Network error in /allocate endpoint: {str(e)}")
                return jsonify({"error": f"Network error: {str(e)}"}), 500
            except Exception as e:
                log(f"[ERROR] Unexpected error in /allocate endpoint: {str(e)}")
                return jsonify({"error": f"Unexpected error: {str(e)}"}), 500
        
        
        # =======================
        # üî¥ Release IP Endpoint
        # =======================
        @app.route('/release', methods=['POST'])
        def release_ip():
            try:
                ip_address = request.json.get('ip_address')
                if not ip_address:
                    return jsonify({"error": "IP address not provided"}), 400
        
                ip_address = ip_address.strip()
        
                with open(IP_FILE_PATH, 'r') as f:
                    ip_list = [line.strip() for line in f.read().splitlines() if line.strip()]
        
                if not ip_list:
                    return jsonify({"error": "IP list is empty"}), 500
        
                # Determine reserved IPs (first two and last one)
                reserved_ips = set(ip_list[:2] + ip_list[-1:])
        
                if ip_address in reserved_ips:
                    return jsonify({"error": f"IP address {ip_address} is reserved and cannot be released."}), 403
        
                if ip_address in ip_list:
                    ip_list.remove(ip_address)
                    with open(IP_FILE_PATH, 'w') as f:
                        f.write("\n".join(ip_list) + "\n")
                    return jsonify({"status": "IP released", "ip": ip_address}), 200
                else:
                    return jsonify({"error": f"IP address {ip_address} not found in the allocation list."}), 404
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        
        
        # =======================
        # üîµ Health Check Endpoint
        # =======================
        @app.route('/health', methods=['GET'])
        def health_check():
            try:
                linode_token = fetch_linode_token()
                if not linode_token:
                    log("[ERROR] Health check: Failed to validate Linode CLI configuration")
                    return jsonify({"status": "unhealthy", "error": "Invalid Linode CLI configuration"}), 500
        
                headers = {"Authorization": f"Bearer {linode_token}"}
                REGION = os.getenv("REGION")
                if not REGION:
                    log("[ERROR] Health check: REGION environment variable not set")
                    return jsonify({"status": "unhealthy", "error": "REGION environment variable not set"}), 500
        
                start_time = time.time()
                response = requests.get("https://api.linode.com/v4/account", headers=headers, timeout=5)
                end_time = time.time()
                latency_ms = (end_time - start_time) * 1000
                if latency_ms > 200:
                    log(f"[WARN] Linode API latency is high: {latency_ms:.2f} ms")
                if response.status_code == 401:
                    log("[ERROR] Health check: Unauthorized access. Token might be invalid")
                    return jsonify({"status": "unhealthy", "error": "Unauthorized access"}), 500
                if response.status_code != 200:
                    log(f"[ERROR] Health check: Failed to connect to Linode API, status {response.status_code}")
                    return jsonify({"status": "unhealthy", "error": "Failed to connect to Linode API"}), 500
        
                response = requests.get("https://api.linode.com/v4/networking/ips", headers=headers, timeout=5)
                if response.status_code != 200:
                    log(f"[ERROR] Health check: Failed to access networking API, status {response.status_code}")
                    return jsonify({"status": "unhealthy", "error": "Failed to access networking API"}), 500
        
                if (
                        REGION_CACHE["timestamp"] is None
                        or (datetime.now() - REGION_CACHE["timestamp"]).total_seconds() > REGION_CACHE["ttl_seconds"]
                ):
                    response = requests.get(f"https://api.linode.com/v4/regions/{REGION}", headers=headers, timeout=5)
                    if response.status_code != 200:
                        log(f"[ERROR] Health check: Invalid or unavailable region {REGION}, status {response.status_code}")
                        return jsonify({"status": "unhealthy", "error": f"Invalid or unavailable region {REGION}"}), 500
                    REGION_CACHE["valid"] = True
                    REGION_CACHE["timestamp"] = datetime.now()
                elif not REGION_CACHE["valid"]:
                    log(f"[ERROR] Health check: Cached result indicates invalid region {REGION}")
                    return jsonify({"status": "unhealthy", "error": f"Invalid or unavailable region {REGION}"}), 500
        
                try:
                    with FileLock(IP_FILE_PATH + ".lock"), open(IP_FILE_PATH, 'a'):
                        pass
                except OSError as e:
                    log(f"[ERROR] Health check: Failed to access IP file: {str(e)}")
                    return jsonify({"status": "unhealthy", "error": f"Failed to access IP file: {str(e)}"}), 500
        
                if not system_health_check():
                    log("[ERROR] Health check: System health checks failed")
                    return jsonify({"status": "unhealthy", "error": "System health checks failed"}), 500
        
                log("[INFO] Health check: All checks passed")
                return jsonify({"status": "healthy", "latency_ms": latency_ms}), 200
        
            except requests.RequestException as e:
                log(f"[ERROR] Health check: Network connectivity error: {str(e)}")
                return jsonify({"status": "unhealthy", "error": f"Network connectivity error: {str(e)}"}), 500
            except Exception as e:
                log(f"[ERROR] Health check: Unexpected error: {str(e)}")
                return jsonify({"status": "unhealthy", "error": f"Unexpected error: {str(e)}"}), 500
        
        
        # =======================
        # üöÄ Start Flask Application
        # =======================
        if __name__ == '__main__':
            validate_environment()
            app.run(host='0.0.0.0', port=8080, debug=True)
