apiVersion: v1
kind: ConfigMap
metadata:
  name: vlan-manager-scripts
  namespace: kube-system
data:
  02-script-vlan-attach.sh: |
        #!/bin/bash
        
        # === Exit on error ===
        set -e
        
        # === Environment Variables ===
        SUBNET="${SUBNET:-10.180.0.0/24}"
        ROUTE_IP="${ROUTE_IP:-10.180.0.1}"
        VLAN_LABEL="${VLAN_LABEL:-private-lan}"
        DEST_SUBNET="${DEST_SUBNET:-10.180.2.0/24}"
        
        # === Logging function ===
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        # === Function to check if VLAN is already attached ===
        is_vlan_attached() {
            VLAN_STATUS=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].purpose // empty')
            if [ "$VLAN_STATUS" == "vlan" ]; then
                return 0
            else
                return 1
            fi
        }
        
        # === Function to push the route ===
        push_route() {
            log "Checking if route already exists for $DEST_SUBNET..."
            
            # Temporarily disable exit-on-error
            set +e
            ip route show | grep -q "$DEST_SUBNET"
            STATUS=$?
            set -e
            
            if [ $STATUS -eq 0 ]; then
                log "‚úÖ Route $DEST_SUBNET already exists. Skipping addition."
            else
                log "‚öôÔ∏è  Adding route $DEST_SUBNET via $ROUTE_IP on eth1..."
                
                # Attempt to add the route
                set +e
                ip route add "$DEST_SUBNET" via "$ROUTE_IP" dev eth1
                ADD_STATUS=$?
                set -e
        
                if [ $ADD_STATUS -eq 0 ]; then
                    log "‚úÖ Route $DEST_SUBNET via $ROUTE_IP successfully added to eth1."
                else
                    log "‚ö†Ô∏è  Failed to add route $DEST_SUBNET via $ROUTE_IP. It may already exist."
                fi
            fi
        }
        
        # === Discover Linode Information ===
        NODE_IP=$(ip addr show eth0 | grep 'inet ' | awk '{print $2}' | grep '^192\.' | cut -d/ -f1)
        NODE_NAME=$(kubectl get nodes -o json | jq -r '.items[] | select(.status.addresses[]?.address == "'"$NODE_IP"'") | .metadata.name')
        
        log "üåê Fetching Public IP of the instance..."
        PUBLIC_IP=$(kubectl get node $NODE_NAME -o jsonpath='{.status.addresses[?(@.type=="ExternalIP")].address}' | awk {'print $1'})
        
        export LINODE_CLI_CONFIG="/root/.linode-cli/linode-cli"
        
        log "üîç Discovering Linode ID for IP $PUBLIC_IP..."
        LINODE_ID=$(linode-cli linodes list --json | jq -r ".[] | select(.ipv4[] | contains(\"$PUBLIC_IP\")) | .id")
        CONFIG_ID=$(linode-cli linodes configs-list $LINODE_ID --json | jq -r '.[0].id')
        
        if [ -z "$LINODE_ID" ] || [ -z "$CONFIG_ID" ]; then
            log "‚ùå Failed to retrieve Linode ID or Config ID. Sleeping for 60 seconds and retrying..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        log "‚úÖ Linode ID: $LINODE_ID, Config ID: $CONFIG_ID"
        
        # === Main Logic ===
        log "üîé Checking if VLAN is already attached to Linode instance $LINODE_ID..."
        if is_vlan_attached; then
            log "‚úÖ VLAN is already attached. Skipping VLAN configuration and directly pushing the route."
            push_route
            log "üõå VLAN configuration complete. Sleeping indefinitely..."
            sleep infinity
        fi
        
        # === VLAN Configuration Logic with Retry ===
        log "‚ùå VLAN is not attached. Proceeding with VLAN configuration..."
        MAX_RETRIES=5
        RETRY_COUNT=0
        SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            log "üîÑ Attempting to allocate IP address... (Attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
            
            set +e
            IP_ADDRESS1=$(/tmp/03-script-ip-allocate.sh $SUBNET)
            STATUS=$?
            set -e
        
            if [ $STATUS -eq 0 ]; then
                IP_ADDRESS=$(echo $IP_ADDRESS1 | awk {'print $NF'})
                if [ -n "$IP_ADDRESS" ]; then
                    log "‚úÖ Allocated IP address: $IP_ADDRESS"
                    SUCCESS=true
                    break
                else
                    log "‚ö†Ô∏è  No IP address found in response. Retrying..."
                fi
            else
                log "‚ùå IP allocation script failed. Retrying..."
            fi
        
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 5
        done
        
        if [ "$SUCCESS" = false ]; then
            log "‚ùå IP allocation failed after $MAX_RETRIES attempts. Retrying in 60 seconds..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        # === Build VLAN JSON ===
        log "‚öôÔ∏è  Building VLAN attachment JSON..."
        INTERFACES_JSON=$(jq -n --arg ip "$IP_ADDRESS" --arg vlan "$VLAN_LABEL" '
            [
              { "type": "public", "purpose": "public" },
              { "type": "vlan", "label": $vlan, "purpose": "vlan", "ipam_address": $ip }
            ]
        ')
        echo $INTERFACES_JSON | jq .
        
        # === Attach the VLAN interface ===
        log "‚öôÔ∏è  Attaching VLAN interface to Linode instance..."
        linode-cli linodes config-update "$LINODE_ID" "$CONFIG_ID" --interfaces "$INTERFACES_JSON" --label "Boot Config"
        
        # === Check Success ===
        if is_vlan_attached; then
            log "‚úÖ VLAN successfully attached. Rebooting Linode..."
            touch /tmp/rebooting 
            linode-cli linodes reboot "$LINODE_ID"
            sleep infinity
        else
            log "‚ùå VLAN configuration failed. Retrying in 60 seconds..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        # === Cleanup Logic ===
        cleanup() {
            if [ -f "/tmp/rebooting" ]; then
                log "Skipping IP release due to planned reboot."
                rm -rfv /tmp/rebooting
            else
                log "Releasing IP address $IP_ADDRESS..."
                /tmp/04-script-ip-release.sh "$IP_ADDRESS"
                log "IP address $IP_ADDRESS released."
            fi
        }
        trap cleanup EXIT
        
        log "‚úÖ VLAN Attachment completed successfully."
        log "üåê Instance $LINODE_ID is now connected to VLAN $VLAN_LABEL with IP $IP_ADDRESS."
        log "üõå Script execution complete. Sleeping indefinitely..."
        sleep infinity

  03-script-ip-allocate.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP allocation
        API_ENDPOINT="http://vlan-leader-service.kube-system.svc.cluster.local:8080/allocate"
        SUBNET=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$SUBNET" ]; then
            error "No subnet provided for IP allocation."
        fi
        
        log "Requesting IP from API at $API_ENDPOINT for Subnet: $SUBNET..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT \
            -H "Content-Type: application/json" \
            -d "{\"subnet\": \"$SUBNET\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            ALLOCATED_IP=$(echo $RESPONSE_BODY | jq -r '.allocated_ip')
            log "Successfully allocated IP: $ALLOCATED_IP"
            echo $ALLOCATED_IP
        else
            case $HTTP_CODE in
                404)
                    error "API Endpoint not found. Service 'vlan-leader-service' may not be running in namespace 'kube-system'."
                    ;;
                500)
                    error "No IP addresses available in the provided subnet."
                    ;;
                400)
                    error "Bad request. The subnet format is incorrect."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi
        
  04-script-ip-release.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP release
        API_ENDPOINT="http://vlan-leader-service.kube-system.svc.cluster.local:8080/release"
        IP_ADDRESS=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$IP_ADDRESS" ]; then
            error "No IP address provided for release."
        fi
        
        log "Requesting IP release from API at $API_ENDPOINT for IP: $IP_ADDRESS..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT -H "Content-Type: application/json" -d "{\"ip_address\": \"$IP_ADDRESS\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            log "Successfully released IP: $IP_ADDRESS"
            echo $IP_ADDRESS
        else
            case $HTTP_CODE in
                404)
                    error "IP address $IP_ADDRESS not found in the allocation list."
                    ;;
                400)
                    error "Bad request. Possibly malformed JSON or missing IP address."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi
        
  05-script-ip-list-initialize.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # File paths for IP allocation
        IP_FILE_PATH="/mnt/vlan-ip/vlan-ip-list.txt"
        RESERVED_IP_FILE="/mnt/vlan-ip/reserved-ips.txt"
        SUBNET=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        # === Check if the file already has data ===
        if [ -f "$IP_FILE_PATH" ] && [ -s "$IP_FILE_PATH" ]; then
            log "IP List file already initialized. Skipping initialization."
            exit 0
        fi
        
        # Initialize the files if not present
        if [ ! -f "$IP_FILE_PATH" ]; then
            log "Creating IP list file at $IP_FILE_PATH"
            touch $IP_FILE_PATH
        fi
        
        if [ ! -f "$RESERVED_IP_FILE" ]; then
            log "Creating Reserved IP list file at $RESERVED_IP_FILE"
            touch $RESERVED_IP_FILE
        fi
        
        if [ -z "$SUBNET" ]; then
            log "No subnet provided. Exiting..."
            exit 1
        fi
        
        # === Calculate IP addresses without ipcalc ===
        NETWORK_PREFIX=$(echo $SUBNET | cut -d'/' -f2)
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo $SUBNET | cut -d'/' -f1)"
        
        # Network IP (x.x.x.0)
        NETWORK_IP="$i1.$i2.$i3.0/$NETWORK_PREFIX"
        
        # First usable IP (x.x.x.1)
        FIRST_IP="$i1.$i2.$i3.1/$NETWORK_PREFIX"
        
        # Broadcast IP (x.x.x.255)
        BROADCAST_IP="$i1.$i2.$i3.255/$NETWORK_PREFIX"
        
        # Reserved IPs Array
        RESERVED_IPS=("$NETWORK_IP" "$FIRST_IP" "$BROADCAST_IP")
        
        log "Reserved IPs for subnet $SUBNET: ${RESERVED_IPS[*]}"
        
        # Adding reserved IPs to both files
        log "Adding reserved IPs to the allocation list and reserved list..."
        for ip in "${RESERVED_IPS[@]}"; do
            if ! grep -q "^$ip$" "$IP_FILE_PATH"; then
                echo "$ip" >> "$IP_FILE_PATH"
                log "Reserved IP added to list: $ip"
            fi
            if ! grep -q "^$ip$" "$RESERVED_IP_FILE"; then
                echo "$ip" >> "$RESERVED_IP_FILE"
                log "Reserved IP added to reserved list: $ip"
            fi
        done
        
        log "Reserved IPs initialization completed."

  06-rest-api.py: |
        from flask import Flask, jsonify, request
        from flask_cors import CORS
        import os
        import ipaddress
        
        app = Flask(__name__)
        CORS(app)
        
        # File path for IP allocation
        IP_FILE_PATH = "/mnt/vlan-ip/vlan-ip-list.txt"
        
        # Initialize the file if not present
        if not os.path.exists(IP_FILE_PATH):
            with open(IP_FILE_PATH, 'w') as f:
                f.write("")
        
        # =======================
        # üü¢ Allocate IP Endpoint
        # =======================
        @app.route('/allocate', methods=['POST'])
        def allocate_ip():
            try:
                # Read the requested subnet
                subnet = request.json.get('subnet')
                if not subnet:
                    return jsonify({"error": "Subnet not provided"}), 400
                
                # Validate the subnet
                try:
                    ip_net = ipaddress.ip_network(subnet, strict=False)
                    cidr_suffix = f"/{ip_net.prefixlen}"
                except ValueError:
                    return jsonify({"error": "Invalid subnet format"}), 400
                
                # Reserved IPs (first, second, and last)
                reserved_ips = {str(ip_net.network_address), str(ip_net[1]), str(ip_net[-1])}
                
                # Read the current IP list
                with open(IP_FILE_PATH, 'r+') as f:
                    ip_list = f.read().splitlines()
                    
                    for ip in ip_net.hosts():
                        candidate_ip = f"{ip}{cidr_suffix}"
                        
                        # Skip reserved IPs
                        if candidate_ip in reserved_ips:
                            continue
        
                        # Check if it's already allocated
                        if candidate_ip not in ip_list:
                            f.write(f"{candidate_ip}\n")
                            return jsonify({"allocated_ip": candidate_ip}), 200
                
                return jsonify({"error": "No IPs available in the range"}), 500
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        # =======================
        # üî¥ Release IP Endpoint
        # =======================
        @app.route('/release', methods=['POST'])
        def release_ip():
            try:
                ip_address = request.json.get('ip_address')
                if not ip_address:
                    return jsonify({"error": "IP address not provided"}), 400
        
                # Read and remove the IP address
                with open(IP_FILE_PATH, 'r') as f:
                    ip_list = [line.strip() for line in f.read().splitlines()]
        
                # Read the reserved IP list
                with open('/mnt/vlan-ip/reserved-ips.txt', 'r') as f:
                    reserved_ips = [line.strip() for line in f.read().splitlines()]
        
                # Strip the input IP too
                ip_address = ip_address.strip()
        
                # === New Logic: Prevent reserved IP release ===
                if ip_address in reserved_ips:
                    return jsonify({"error": f"IP address {ip_address} is reserved and cannot be released."}), 403
        
                if ip_address in ip_list:
                    ip_list.remove(ip_address)
                    with open(IP_FILE_PATH, 'w') as f:
                        f.write("\n".join(ip_list) + "\n")
                    return jsonify({"status": "IP released", "ip": ip_address}), 200
                else:
                    return jsonify({"error": f"IP address {ip_address} not found in the allocation list."}), 404
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        # =======================
        # üîµ Health Check Endpoint
        # =======================
        @app.route('/health', methods=['GET'])
        def health_check():
            return jsonify({"status": "healthy"}), 200
        
        # =======================
        # üöÄ Start Flask Application
        # =======================
        if __name__ == '__main__':
            app.run(host='0.0.0.0', port=8080, debug=True)
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: linode-cli-config
  namespace: kube-system
data:
  linode-cli: |
      [DEFAULT]
      default-user = sandip_akamai
      
      [sandip_akamai]
      token = 33a230605268bc6303fed1fa81c5888770f93bf290f06fbb7eb9e7fe9e4fd65c
      region = in-maa
      authorized_users = sandip_akamai
      suppress-version-warning = true
