# 04-vlan-manager-scripts-configmap.yaml
# 
# This YAML file defines the ConfigMap for VLAN Manager scripts in Linode LKE.
# It includes the following scripts for IP allocation, release, VLAN attachment,
# and IP list initialization:
# 
# 1Ô∏è‚É£ 02-script-vlan-attach.sh   - Attaches the VLAN to the Linode instance and sets up routing.
# 2Ô∏è‚É£ 03-script-ip-allocate.sh   - Allocates an IP address from the subnet.
# 3Ô∏è‚É£ 04-script-ip-release.sh    - Releases the IP address back to the pool.
# 4Ô∏è‚É£ 05-script-ip-list-initialize.sh - Initializes the IP list from the subnet.
# 5Ô∏è‚É£ 06-rest-api.py             - REST API to manage IP allocation and release.
# 
# -----------------------------------------------------
# üìù Parameters:
# 
# 1Ô∏è‚É£ SUBNET            - Subnet for IP allocation.
# 2Ô∏è‚É£ ROUTE_IP          - Gateway IP for the primary subnet.
# 3Ô∏è‚É£ VLAN_LABEL        - VLAN identifier for Linode.
# 4Ô∏è‚É£ DEST_SUBNET       - Destination subnet for routing.
# 5Ô∏è‚É£ API_ENDPOINT      - URL for IP allocation and release.
# 
# -----------------------------------------------------
# üîÑ Usage:
# 
# - These scripts are mounted into the VLAN Manager Pod and executed during
#   VLAN attachment, IP allocation, and IP release processes.
# - Communication is handled through the configured API endpoints.
# 
# -----------------------------------------------------
# üìå Best Practices:
# 
# - Ensure the VLAN label and subnet are correctly configured before running.
# - Monitor logs for connectivity issues during VLAN attachment.
# - Use health checks to validate API availability before IP allocation.
# 
# -----------------------------------------------------
# üñãÔ∏è Author:
# - Sandip Gangdhar
# - GitHub: https://github.com/sandipgangdhar
# 
# ¬© Linode-LKE-Private-Network | Developed by Sandip Gangdhar | 2025
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vlan-manager-scripts
  namespace: kube-system
data:
  02-script-vlan-attach.sh: |
        #!/bin/bash
        set -e
        
        # === Environment Variables ===
        # These variables are populated from Kubernetes ConfigMap or environment
        SUBNET="${SUBNET}"
        ROUTE_IP="${ROUTE_IP}"
        VLAN_LABEL="${VLAN_LABEL}"
        DEST_SUBNET="${DEST_SUBNET}"
        ENABLE_PUSH_ROUTE="$(echo "$ENABLE_PUSH_ROUTE" | tr '[:upper:]' '[:lower:]')"  # flag to control route pushing
        ENABLE_FIREWALL="$(echo "$ENABLE_FIREWALL" | tr '[:upper:]' '[:lower:]')" # flag to control FIREWALL Creation and attachment
        LKE_CLUSTER_ID="${LKE_CLUSTER_ID}"
        
        # === Function to Log Events ===
        # This function logs events with a timestamp
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        log "üîÑ Starting VLAN Attachment Script..."
        
        # === Function to check if VLAN is already attached ===
        is_vlan_attached() {
            VLAN_STATUS=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].purpose // empty')
            if [ "$VLAN_STATUS" == "vlan" ]; then
                return 0
            else
                return 1
            fi
        }
        
        # === Function to push the route ===
        push_route() {
            if [[ "$ENABLE_PUSH_ROUTE" == "true" ]]; then
        
                # === Route Push Validation Logic ===
                # This block conditionally validates routing variables only if route pushing is enabled.
                #
                # - ENABLE_PUSH_ROUTE: If set to "true", the script will attempt to push a static route.
                # - ROUTE_IP and DEST_SUBNET must be set with valid non-placeholder values if ENABLE_PUSH_ROUTE is true.
                #
                # If ENABLE_PUSH_ROUTE is "false" (default), this block is skipped entirely and
                # ROUTE_IP / DEST_SUBNET are ignored.
                #
                # Note: Even if ignored, placeholder values like "0.0.0.0" should be provided in the ConfigMap
                #       to maintain Kubernetes YAML consistency.
        
                if [[ -z "$ROUTE_IP" || "$ROUTE_IP" == "0.0.0.0" || -z "$DEST_SUBNET" || "$DEST_SUBNET" == "0.0.0.0/0" ]]; then
                    log "‚ùå ENABLE_PUSH_ROUTE is true, but ROUTE_IP or DEST_SUBNET is unset or invalid."
                    log "üõë Skipping route push and sleeping indefinitely to avoid container crash loop."
                    sleep infinity
                fi
                log "üì¶ ENABLE_PUSH_ROUTE value is: $ENABLE_PUSH_ROUTE"
                log "üì¶ ROUTE_IP value is: $ROUTE_IP"
                log "üì¶ DEST_SUBNET value is: $DEST_SUBNET"
        
                log "Checking if route already exists for $DEST_SUBNET..."
            
                # Temporarily disable exit-on-error
                set +e
                ip route show | grep -q "$DEST_SUBNET"
                STATUS=$?
                set -e
                
                if [ $STATUS -eq 0 ]; then
                    log "‚úÖ Route $DEST_SUBNET already exists. Skipping addition."
                else
                    log "‚öôÔ∏è  Adding route $DEST_SUBNET via $ROUTE_IP on eth1..."
                    
                    # Attempt to add the route
                    set +e
                    ip route add "$DEST_SUBNET" via "$ROUTE_IP" dev eth1
                    ADD_STATUS=$?
                    set -e
            
                    if [ $ADD_STATUS -eq 0 ]; then
                        log "‚úÖ Route $DEST_SUBNET via $ROUTE_IP successfully added to eth1."
                    else
                        log "‚ö†Ô∏è  Failed to add route $DEST_SUBNET via $ROUTE_IP. It may already exist."
                    fi
                fi
            else
                log "‚ÑπÔ∏è Skipping route push as ENABLE_PUSH_ROUTE is set to false."
            fi
        }
        
        # === Function to create and attach firewall ===
        create_and_attach_firewall() {
            if [[ "$ENABLE_FIREWALL" != "true" ]]; then
                log "‚ÑπÔ∏è Skipping firewall creation as ENABLE_FIREWALL is set to false."
                return 0
            fi

            FIREWALL_LABEL="lke-cluster-firewall-${LKE_CLUSTER_ID}"
            log "üîç Checking if firewall '$FIREWALL_LABEL' already exists..."

            set +e
            FIREWALL_ID=$(linode-cli firewalls list --json 2>/dev/null | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
            set -e

            if [[ -z "$FIREWALL_ID" ]]; then
                log "üöÄ Creating new firewall with label $FIREWALL_LABEL..."
                set +e
                CREATE_OUTPUT=$(linode-cli firewalls create \
                  --label "$FIREWALL_LABEL" \
                  --rules.inbound='[
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "10250,10256", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Kubelet_Health_Checks"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "51820", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "kubectl_proxy_Wireguard_tunnel"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "53", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "TCP_cluster_DNS_access"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "53", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "UDP_cluster_DNS_access"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "179", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Calico_BGP_traffic"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "5473", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Calico_Typha_traffic"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "30000-32767", "addresses": { "ipv4": ["192.168.255.0/24"] }, "label": "NodeBalancer_TCP"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "30000-32767", "addresses": { "ipv4": ["192.168.255.0/24"] }, "label": "NodeBalancer_UDP"},
                    {"action": "ACCEPT", "protocol": "IPENCAP", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "NP_CP_communication"}
                  ]' \
                  --rules.outbound='[
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "1-65535", "addresses": { "ipv4": ["0.0.0.0/0"] }, "label": "Allow_All_TCP_Outbound"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "1-65535", "addresses": { "ipv4": ["0.0.0.0/0"] }, "label": "Allow_All_UDP_Outbound"}
                  ]' \
                  --rules.inbound_policy="DROP" \
                  --rules.outbound_policy="ACCEPT" \
                  --json)
                CREATE_STATUS=$?
                set -e

                if [[ $CREATE_STATUS -ne 0 || -z "$CREATE_OUTPUT" ]]; then
                    log "‚ùå Failed to create firewall $FIREWALL_LABEL. Sleeping indefinitely to avoid crashloop."
                    sleep infinity
                fi

                FIREWALL_ID=$(echo "$CREATE_OUTPUT" | jq -r '.[0].id')
                log "‚úÖ Firewall created with ID $FIREWALL_ID"
            else
                log "‚úÖ Firewall $FIREWALL_LABEL already exists with ID $FIREWALL_ID"
            fi

            # Check if any firewall is already attached to this Linode
            log "üîç Verifying if Linode ID $LINODE_ID already has any firewall attached..."
            FIREWALLS_WITH_ENTITIES=$(linode-cli firewalls list --json | jq -r '.[] | select(.entities != null) | @base64')
            for fw in $FIREWALLS_WITH_ENTITIES; do
                _jq() { echo "$fw" | base64 --decode | jq -r "$1"; }
                FW_ID=$(_jq '.id')
                ENTITY_IDS=$(linode-cli firewalls view "$FW_ID" --json | jq -r '.[0].entities[]?.id')
                for id in $ENTITY_IDS; do
                    if [[ "$id" == "$LINODE_ID" ]]; then
                        log "‚ö†Ô∏è Linode ID $LINODE_ID already has a firewall attached (Firewall ID: $FW_ID). Skipping attachment."
                        return 0
                    fi
                done
            done

            log "üîó Attaching firewall $FIREWALL_LABEL to Linode instance $LINODE_ID..."
            set +e
            linode-cli firewalls device-create "$FIREWALL_ID" --type linode --id "$LINODE_ID"
            ATTACH_STATUS=$?
            set -e

            if [[ $ATTACH_STATUS -eq 0 ]]; then
                # Wait for firewall to be fully attached before proceeding
                ATTACH_WAIT_RETRIES=10
                ATTACH_WAIT_DELAY=5
                for i in $(seq 1 $ATTACH_WAIT_RETRIES); do
                    FIREWALL_DEVICE_STATUS=$(linode-cli firewalls devices-list "$FIREWALL_ID" --json | jq -r ".[] | select(.id == $LINODE_ID) | .status")
                    if [[ "$FIREWALL_DEVICE_STATUS" == "enabled" ]]; then
                        log "‚úÖ Firewall attachment confirmed (status: enabled)"
                        break
                    else
                        log "‚è≥ Waiting for firewall to attach (attempt $i/$ATTACH_WAIT_RETRIES)..."
                        sleep "$ATTACH_WAIT_DELAY"
                    fi
                done
                log "‚úÖ Firewall successfully attached to Linode ID $LINODE_ID"
                log "üõ°Ô∏è Firewall ENABLED ‚Äì Firewall '$FIREWALL_LABEL' (ID: $FIREWALL_ID) successfully created/attached to instance."
                log "‚úÖ Firewall attachment complete. Continuing to finalize script execution..."
            else
                log "‚ùå Failed to attach firewall to Linode ID $LINODE_ID. Sleeping indefinitely to avoid container restart loop."
                sleep infinity
            fi
        }
        
        # === Discover Node IP and Name ===
        # Retrieve the IP address of eth0 (assumed to be the main interface)
        log "üåê Fetching NODE IP of the instance..."
        NODE_IP=$(ip addr show eth0 | grep -v "eth0:[0-9]" | grep -w inet | awk {'print $2'}|awk -F'/' {'print $1'})
        
        log "üåê Node IP: $NODE_IP"
        
        # Query Kubernetes to find the node name associated with this IP
        log "üåê Fetching NODE NAME of the instance..."
        NODE_NAME=$(kubectl get nodes -o json | jq -r '.items[] | select(.status.addresses[]?.address == "'"$NODE_IP"'") | .metadata.name')
        
        log "üåê Node Name: $NODE_NAME"
        
        # === Fetch Public IP of the Node ===
        # This fetches the public IP associated with the node from the Kubernetes API
        log "üåê Fetching Public IP of the instance..."
        PUBLIC_IP=$(kubectl get node $NODE_NAME -o jsonpath='{.status.addresses[?(@.type=="ExternalIP")].address}' | awk {'print $1'})
        log "üåê Public IP of the Node: $PUBLIC_IP"
        
        export LINODE_CLI_CONFIG="/root/.linode-cli/linode-cli"
        
        # === Discover Linode ID and Configuration ID ===
        # Linode API calls to find the instance ID and its configuration ID
        LINODE_ID=$(linode-cli linodes list --json | jq -r ".[] | select(.ipv4[] | contains(\"$PUBLIC_IP\")) | .id")
        CONFIG_ID=$(linode-cli linodes configs-list $LINODE_ID --json | jq -r '.[0].id')
        
        # If either the Linode ID or Config ID is not found, retry after 60 seconds
        if [ -z "$LINODE_ID" ] || [ -z "$CONFIG_ID" ]; then
            log "‚ùå Failed to retrieve Linode ID or Config ID. Sleeping for 60 seconds and retrying..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        log "‚úÖ Linode ID: $LINODE_ID, Config ID: $CONFIG_ID"
        
        # === Main Logic ===
        log "üîé Checking if VLAN is already attached to Linode instance $LINODE_ID..."
        if is_vlan_attached; then
            log "‚úÖ VLAN is already attached. Skipping VLAN configuration and directly pushing the route."
            push_route
            create_and_attach_firewall
            log "üõå VLAN configuration complete. Sleeping indefinitely..."
            sleep infinity
        fi
        
        # === VLAN Configuration Logic with Retry ===
        log "‚ùå VLAN is not attached. Proceeding with VLAN configuration..."
        MAX_RETRIES=5
        RETRY_COUNT=0
        SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            log "üîÑ Attempting to allocate IP address... (Attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
            
            set +e
            IP_ADDRESS1=$(/tmp/03-script-ip-allocate.sh $SUBNET)
            STATUS=$?
            set -e
        
            if [ $STATUS -eq 0 ]; then
                IP_ADDRESS=$(echo $IP_ADDRESS1 | awk {'print $NF'})
                if [ -n "$IP_ADDRESS" ]; then
                    log "‚úÖ Allocated IP address: $IP_ADDRESS"
                    SUCCESS=true
                    break
                else
                    log "‚ö†Ô∏è  No IP address found in response. Retrying..."
                fi
            else
                log "‚ùå IP allocation script failed. Retrying..."
            fi
        
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 5
        done
        
        if [ "$SUCCESS" = false ]; then
            log "‚ùå IP allocation failed after $MAX_RETRIES attempts. Retrying in 60 seconds..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        # === Build VLAN JSON ===
        log "‚öôÔ∏è  Building VLAN attachment JSON..."
        INTERFACES_JSON=$(jq -n --arg ip "$IP_ADDRESS" --arg vlan "$VLAN_LABEL" '
            [
              { "type": "public", "purpose": "public" },
              { "type": "vlan", "label": $vlan, "purpose": "vlan", "ipam_address": $ip }
            ]
        ')
        echo $INTERFACES_JSON | jq .
        
        # === Attach the VLAN interface ===
        log "‚öôÔ∏è  Attaching VLAN interface to Linode instance..."
        linode-cli linodes config-update "$LINODE_ID" "$CONFIG_ID" --interfaces "$INTERFACES_JSON" --label "Boot Config"
        
        # === Check Success ===
        if is_vlan_attached; then
            log "‚úÖ VLAN successfully attached."
            create_and_attach_firewall
            touch /tmp/rebooting
            log "Rebooting Linode after firewall confirmed attached..."
            linode-cli linodes reboot "$LINODE_ID"
            sleep infinity
        else
            log "‚ùå VLAN configuration failed. Retrying in 60 seconds..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        # === Cleanup Logic ===
        cleanup() {
            if [ -f "/tmp/rebooting" ]; then
                log "Skipping IP release due to planned reboot."
                rm -rfv /tmp/rebooting
            else
                log "Releasing IP address $IP_ADDRESS..."
                /tmp/04-script-ip-release.sh "$IP_ADDRESS"
                log "IP address $IP_ADDRESS released."
            fi
        }
        trap cleanup EXIT
        
        log "‚úÖ VLAN Attachment completed successfully."
        log "üåê Instance $LINODE_ID is now connected to VLAN $VLAN_LABEL with IP $IP_ADDRESS."
        # The following block is removed because firewall success is now logged in create_and_attach_firewall:
        # if [[ "$ENABLE_FIREWALL" == "true" ]]; then
        #     if [[ -n "$FIREWALL_ID" ]]; then
        #         log "üõ°Ô∏è Firewall ENABLED ‚Äì Firewall '$FIREWALL_LABEL' (ID: $FIREWALL_ID) successfully created/attached to instance."
        #     else
        #         log "‚ö†Ô∏è Firewall ENABLED ‚Äì but Firewall ID not set. Check previous logs for errors during creation or attachment."
        #     fi
        # else
        #     log "‚ÑπÔ∏è Firewall DISABLED ‚Äì Skipping firewall creation and attachment as ENABLE_FIREWALL is set to false."
        # fi
        log "üü¢ VLAN and Firewall configuration steps completed successfully."
        log "üõå Script execution complete. Sleeping indefinitely..."
        sleep infinity
  03-script-ip-allocate.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP allocation
        API_ENDPOINT="http://vlan-leader-service.kube-system.svc.cluster.local:8080/allocate"
        SUBNET=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$SUBNET" ]; then
            error "No subnet provided for IP allocation."
        fi
        
        log "Requesting IP from API at $API_ENDPOINT for Subnet: $SUBNET..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT \
            -H "Content-Type: application/json" \
            -d "{\"subnet\": \"$SUBNET\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            ALLOCATED_IP=$(echo $RESPONSE_BODY | jq -r '.allocated_ip')
            log "Successfully allocated IP: $ALLOCATED_IP"
            echo $ALLOCATED_IP
        else
            case $HTTP_CODE in
                404)
                    error "API Endpoint not found. Service 'vlan-leader-service' may not be running in namespace 'kube-system'."
                    ;;
                500)
                    error "No IP addresses available in the provided subnet."
                    ;;
                400)
                    error "Bad request. The subnet format is incorrect."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi
        
  04-script-ip-release.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP release
        API_ENDPOINT="http://vlan-leader-service.kube-system.svc.cluster.local:8080/release"
        IP_ADDRESS=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$IP_ADDRESS" ]; then
            error "No IP address provided for release."
        fi
        
        log "Requesting IP release from API at $API_ENDPOINT for IP: $IP_ADDRESS..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT -H "Content-Type: application/json" -d "{\"ip_address\": \"$IP_ADDRESS\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            log "Successfully released IP: $IP_ADDRESS"
            echo $IP_ADDRESS
        else
            case $HTTP_CODE in
                404)
                    error "IP address $IP_ADDRESS not found in the allocation list."
                    ;;
                400)
                    error "Bad request. Possibly malformed JSON or missing IP address."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi
        
  05-script-ip-list-initialize.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        #!/bin/bash
        # Exit on error
        set -e
        
        # --- Define Color Codes ---
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[1;34m'
        NC='\033[0m' # No Color
        
        LINODE_TOKEN="${LINODE_TOKEN}"
        #LINODE_TOKEN=`grep token /root/.linode-cli/linode-cli | awk -F'= ' {'print $2'}`
        OUTPUT_FILE="/tmp/vlan-ip-list.txt"
        PAGE_SIZE=100
        CURRENT_PAGE=1
        TOTAL_PAGES=1
        MAX_RETRIES=3
        BACKOFF_BASE=2
        INITIAL_JOBS=5
        MAX_JOBS=20
        
        # === Environment Variables ===
        # File path for IP list storage
        IP_FILE_PATH=$OUTPUT_FILE
        
        # Subnet is passed as the first argument
        SUBNET=$1
        REGION=$2
        
        # === Function to Log Events ===
        # This function logs events with timestamps for better traceability
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        # === Validate Subnet is Provided ===
        # If the subnet is not passed as an argument, exit with an error
        log "[DEBUG] Script received SUBNET=$SUBNET REGION=$REGION"
        if [ -z "$SUBNET" ]; then
            log "[ERROR] No subnet provided for initialization."
            exit 1
        fi
        
        # === Validate if Region is Provided ===
        # If the region is not passed as an argument, exit with an error
        if [ -z "$REGION" ]; then
            log "[ERROR] No REGION provided for initialization."
            exit 1
        fi
        
        log "üîÑ Starting IP List Initialization..."
        
        log "üåê Subnet provided for initialization: $SUBNET"
        
        # --- Retry Logic Wrapper with Intelligent Backoff and 404 Handling ---
        retry_curl() {
            local URL=$1
            local OUTPUT=$2
            local RETRY_COUNT=0
            local BACKOFF=1
            local SUCCESS=false
        
            while [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
                echo -e "${BLUE}üåê Attempting API call: $URL (Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)${NC}"
                
                START_TIME=$(date +%s)  # Start timer
        
                if [[ "$URL" == *"/linode/instances/"*"/configs" ]]; then
                    HTTP_CODE=$(curl -s -w "%{http_code}" -H "Authorization: Bearer $LINODE_TOKEN" \
                                "$URL" -o "$OUTPUT")
                else
                    HTTP_CODE=$(curl -s -w "%{http_code}" -H "Authorization: Bearer $LINODE_TOKEN" \
                                -H 'X-Filter: {"region": "'$REGION'"}' \
                                "$URL" -o "$OUTPUT")
                fi
        
                END_TIME=$(date +%s)    # End timer
                DURATION=$((END_TIME - START_TIME))
                echo "$URL | $DURATION ms" >> latency-log.txt
        
                case "$HTTP_CODE" in
                    200)
                        if [ -s "$OUTPUT" ]; then
                            SUCCESS=true
                            echo -e "${GREEN}‚úÖ API call successful ($DURATION ms): $URL${NC}"
                            break
                        fi
                        ;;
                    404)
                        echo -e "${RED}‚ùå [404] Resource not found: $URL${NC}" | tee -a error-log.txt
                        echo -e "${YELLOW}   ‚û°Ô∏è  Skipping further retries for this resource.${NC}"
                        return 1
                        ;;
                    429)
                        echo -e "${YELLOW}‚ö†Ô∏è Rate limit hit. Backing off for $BACKOFF seconds...${NC}"
                        sleep "$BACKOFF"
                        BACKOFF=$((BACKOFF * BACKOFF_BASE))
                        ;;
                    *)
                        echo -e "${RED}‚ö†Ô∏è API call failed with HTTP Code $HTTP_CODE, retrying in $BACKOFF seconds...${NC}"
                        sleep "$BACKOFF"
                        BACKOFF=$((BACKOFF * BACKOFF_BASE))
                        ;;
                esac
        
                ((RETRY_COUNT++))
            done
        
            if [ "$SUCCESS" = false ] && [ "$HTTP_CODE" != "404" ]; then
                echo -e "${RED}‚ùå API call failed after $MAX_RETRIES attempts: $URL${NC}" | tee -a error-log.txt
            fi
        }
        
        # --- Step 1: Paginated Fetch for All Linode IDs in the region with X-Filter ---
        echo -e "${BLUE}üåê Fetching Linode IDs in region $REGION with Pagination...${NC}"
        while [ "$CURRENT_PAGE" -le "$TOTAL_PAGES" ]; do
            echo -e "${BLUE}   ‚û°Ô∏è  Fetching page $CURRENT_PAGE of $TOTAL_PAGES${NC}"
            
            URL="https://api.linode.com/v4/linode/instances?page=$CURRENT_PAGE&page_size=$PAGE_SIZE"
            TEMP_RESPONSE=$(mktemp)
            
            # Fetch paginated data with retry logic
            retry_curl "$URL" "$TEMP_RESPONSE"
            
            # Fetch Linode IDs and append to file
            cat "$TEMP_RESPONSE" | jq -r '.data[] | .id' >> linodes.txt
            
            # Get pagination info
            TOTAL_PAGES=$(cat "$TEMP_RESPONSE" | jq -r '.pages')
            CURRENT_PAGE=$((CURRENT_PAGE + 1))
            rm -f "$TEMP_RESPONSE"
        done
        
        # --- Step 2: Count the number of Linode IDs and adjust MAX_JOBS ---
        TOTAL_LINODES=$(wc -l < linodes.txt)
        if [ "$TOTAL_LINODES" -lt "$INITIAL_JOBS" ]; then
            MAX_JOBS="$TOTAL_LINODES"
        else
            # --- Adjust parallel jobs based on latency ---
            AVG_LATENCY=$(awk '{sum+=$3} END {print int(sum/NR)}' latency-log.txt)
            
            if [ "$AVG_LATENCY" -lt 200 ]; then
                MAX_JOBS=20
            elif [ "$AVG_LATENCY" -lt 500 ]; then
                MAX_JOBS=10
            else
                MAX_JOBS=5
            fi
        fi
        
        echo -e "${GREEN}üîé Found $TOTAL_LINODES Linode IDs. Adjusting parallel jobs to $MAX_JOBS (Avg Latency: $AVG_LATENCY ms)${NC}"
        
        # --- Step 3: Function to fetch VLAN IPs for a single Linode ---
        fetch_vlan_ips() {
            local LID=$1
            local TEMP_FILE=$(mktemp)
            local TEMP_RESPONSE=$(mktemp)
            echo -e "${GREEN}üîé Checking Linode ID: $LID${NC}"
        
            # Fetch configurations for the Linode with retry logic and X-Filter for interfaces
            URL="https://api.linode.com/v4/linode/instances/$LID/configs"
            retry_curl "$URL" "$TEMP_RESPONSE"
        
            if [ $? -ne 0 ]; then
                echo -e "${RED}‚ùå [ERROR] Failed to fetch configs for Linode ID $LID${NC}" | tee -a error-log.txt
                return 1
            fi
        
            # Extract VLAN IPs directly (No additional curl calls)
            VLAN_IPS=$(cat "$TEMP_RESPONSE" | jq -r ".data[].interfaces[] | select(.purpose == \"vlan\") | .ipam_address")
        
            # Write to the temp file and success log
            if [ -n "$VLAN_IPS" ]; then
                echo "$VLAN_IPS" >> "$TEMP_FILE"
                echo -e "${GREEN}‚úÖ [SUCCESS] VLAN IPs found for Linode ID $LID - $VLAN_IPS${NC}" | tee -a success-log.txt
            else
                echo -e "${YELLOW}‚ö†Ô∏è [INFO] No VLAN IPs found for Linode ID $LID${NC}" | tee -a success-log.txt
            fi
        
            # Append temp file to final output (atomic operation)
            if [ -s "$TEMP_FILE" ]; then
                cat "$TEMP_FILE" >> "$OUTPUT_FILE"
            fi
        
            rm -f "$TEMP_FILE" "$TEMP_RESPONSE"
        }
        
        # === Calculate IP addresses without ipcalc ===
        NETWORK_PREFIX=$(echo $SUBNET | cut -d'/' -f2)
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo $SUBNET | cut -d'/' -f1)"
        
        # Extract the IP segments correctly
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo "$SUBNET" | cut -d'/' -f1)"
        
        # Sanity check
        if [ -z "$i1" ] || [ -z "$i2" ] || [ -z "$i3" ]; then
            echo -e "${RED}[ERROR] Subnet parsing failed. Please check the subnet format.${NC}"
            exit 1
        fi
        
        # Network IP (x.x.x.0)
        NETWORK_IP="${i1}.${i2}.${i3}.0/$NETWORK_PREFIX"
        
        # First usable IP (x.x.x.1)
        FIRST_IP="${i1}.${i2}.${i3}.1/$NETWORK_PREFIX"
        
        # Broadcast IP (x.x.x.255)
        BROADCAST_IP="${i1}.${i2}.${i3}.255/$NETWORK_PREFIX"
        
        # Reserved IPs Array
        RESERVED_IPS=("$NETWORK_IP" "$FIRST_IP" "$BROADCAST_IP")
        
        log "Reserved IPs for subnet $SUBNET: ${RESERVED_IPS[*]}"
        
        # Adding reserved IPs to $IP_FILE_PATH files
        log "Adding reserved IPs to the allocation list for reserving it..."
        for ip in "${RESERVED_IPS[@]}"; do
            if ! grep -q "^$ip$" "$IP_FILE_PATH"; then
                echo "$ip" >> "$IP_FILE_PATH"
                log "Reserved IP added to list: $ip"
            fi
        done
        
        # --- Export function and variables for parallel ---
        export -f fetch_vlan_ips retry_curl
        export LINODE_TOKEN OUTPUT_FILE MAX_RETRIES
        
        # --- Step 4: Parallel Processing of Linode IDs ---
        echo -e "${BLUE}üåê Fetching VLAN IPs from configurations in parallel...${NC}"
        cat linodes.txt | parallel -j "$MAX_JOBS" fetch_vlan_ips {}
        
        # --- Cleanup ---
        rm -f linodes.txt
        
        # === Remove duplicates ===
        sort -u "$OUTPUT_FILE" -o "$OUTPUT_FILE"
        
        log "‚úÖ VLAN IP file created at $OUTPUT_FILE"
        
        # === Write to etcd using etcdctl txn ===
        log "üíæ Syncing IPs to etcd..." 
        log "‚úÖ ETCD_ENDPOINTS is $ETCD_ENDPOINTS"
        
        if [ -z "$ETCD_ENDPOINTS" ]; then
            log "[ERROR] ETCD_ENDPOINTS not set."
            exit 1
        fi
        
        export ETCDCTL_API=3     
        
        while IFS= read -r ip; do
            key="/vlan/ip/$ip"
            output=$(etcdctl --endpoints="$ETCD_ENDPOINTS" put --prev-kv "$key" "true" 2>&1)
            if [[ "$output" == *"prev_kv"* ]]; then
                log "üîÅ IP $ip already exists in etcd, skipping."
            else
                log "‚úÖ IP $ip synced to etcd."
            fi
        done < "$OUTPUT_FILE"
        
        log "üéâ Initialization and etcd sync complete."

        echo -e "${GREEN}‚úÖ VLAN IP Initialization Complete. IPs saved to etcd database."
        
        # --- Final Output ---
        cat "$OUTPUT_FILE"
        
        log "‚úÖ IP List Initialization Complete. Saved to $IP_FILE_PATH"
  06-rest-api.py: |
        # Import necessary libraries for web server, concurrency, networking, and file handling
        from flask import Flask, jsonify, request
        from flask_cors import CORS
        import os
        import ipaddress
        import json
        import sys
        import time
        from filelock import FileLock
        import requests
        from concurrent.futures import ThreadPoolExecutor
        from datetime import datetime, timedelta
        import asyncio
        import aiohttp
        import psutil
        import signal
        import configparser
        import etcd3
        import random
        
        # Initialize Flask application instance
        app = Flask(__name__)
        # Enable Cross-Origin Resource Sharing (CORS) for this Flask app
        CORS(app)
        
        # Define the log file path for logging allocation and healthcheck events
        LOG_FILE = "/tmp/allocate-ip.log"
        
        # Maximum number of log lines to retain in the log file
        MAX_LOG_LINES = 1000
        
        # Maximum backoff time in seconds for retry loops (e.g., API retries)
        MAX_BACKOFF = 60
        
        # Cache dictionary to store VLAN IPs with a TTL for performance
        VLAN_IP_CACHE = {
            "ips": None,
            "timestamp": None,
            "ttl_seconds": int(os.getenv("CACHE_TTL_SECONDS", 60))
        }
        
        # Cache to validate region metadata to reduce repetitive API calls
        REGION_CACHE = {"valid": False, "timestamp": None, "ttl_seconds": 3600}
        
        
        # Signal handler to gracefully shutdown the app when terminated
        def graceful_exit(signalnum, frame):
            log(f"[INFO] Received signal {signalnum}. Shutting down gracefully...")
            sys.exit(0)
        
        
        # Register signal handlers for SIGTERM and SIGINT (Ctrl+C)
        signal.signal(signal.SIGTERM, graceful_exit)
        
        # Register signal handlers for SIGTERM and SIGINT (Ctrl+C)
        signal.signal(signal.SIGINT, graceful_exit)
        
        
        
        def validate_environment():
            REGION = os.getenv("REGION")
            if not REGION:
                log("[ERROR] REGION environment variable not set.")
                sys.exit(1)
            if not os.getenv("ETCD_ENDPOINTS"):
                log("[ERROR] ETCD_ENDPOINTS environment variable not set.")
                sys.exit(1)
        
            log("[INFO] Environment validation passed.")
        
        def log(message):
            timestamped_message = f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {message}"
            print(timestamped_message)
            sys.stdout.flush()
        
            try:
                with FileLock(LOG_FILE + ".lock"):
                    lines = []
        
                    # Read existing log if available
                    if os.path.exists(LOG_FILE):
                        with open(LOG_FILE, "r") as f:
                            lines = f.read().splitlines()
        
                    # Append new log entry and trim if necessary
                    lines.append(timestamped_message)
                    lines = lines[-MAX_LOG_LINES:]
        
                    # Write back to log file
                    with open(LOG_FILE, "w") as f:
                        f.write("\n".join(lines) + "\n")
            except Exception as e:
                print(f"[ERROR] Failed to write to log file: {str(e)}")
        
        
        def api_request_with_retry(url, headers, retries=3, backoff=2, jitter=True):
            """
            Make an HTTP GET request with retry, exponential backoff, and optional jitter.
            """
            for attempt in range(1, retries + 1):
                try:
                    response = requests.get(url, headers=headers, timeout=5)
        
                    if response.status_code == 200:
                        try:
                            return response.json()
                        except ValueError:
                            log(f"[ERROR] Invalid JSON response on attempt {attempt}: {response.text}")
                            return None
        
                    elif response.status_code == 429:
                        wait_time = int(response.headers.get("Retry-After", 5))
                        log(f"[WARN] Rate limited (429). Retrying after {wait_time}s (attempt {attempt}/{retries})")
                        time.sleep(wait_time)
        
                    elif response.status_code >= 500:
                        log(f"[WARN] Server error {response.status_code} on attempt {attempt}. Retrying...")
                        _sleep_with_backoff(backoff, attempt, jitter)
        
                    else:
                        log(f"[WARN] API error {response.status_code} on attempt {attempt}. Retrying...")
                        _sleep_with_backoff(backoff, attempt, jitter)
        
                except (requests.ConnectionError, requests.Timeout) as e:
                    log(f"[ERROR] Network error on attempt {attempt}: {str(e)}. Retrying...")
                    _sleep_with_backoff(backoff, attempt, jitter)
        
                except requests.RequestException as e:
                    log(f"[ERROR] Unexpected error on attempt {attempt}: {str(e)}. Retrying...")
                    _sleep_with_backoff(backoff, attempt, jitter)
        
            log(f"[ERROR] API call failed after {retries} attempts.")
            return None
        
        
        def _sleep_with_backoff(base_backoff, attempt, jitter=True):
            wait_time = min(base_backoff * (2 ** (attempt - 1)), MAX_BACKOFF)
            if jitter:
                wait_time += random.uniform(0.1, 0.5)
            log(f"[DEBUG] Waiting {wait_time:.2f}s before retrying...")
            time.sleep(wait_time)
        
        
        def fetch_linode_token(config_file='/root/.linode-cli/linode-cli'):
            """
            Read the Linode CLI config file and extract the token for the default user.
        
            Args:
                config_file (str): Path to the Linode CLI configuration file
        
            Returns:
                str: The token value, or None if not found
            """
            if not os.path.exists(config_file):
                log(f"[ERROR] Configuration file {config_file} not found")
                return None
        
            config = configparser.ConfigParser()
        
            try:
                config.read(config_file)
        
                if 'DEFAULT' not in config or 'default-user' not in config['DEFAULT']:
                    log(f"[ERROR] No 'default-user' found in {config_file}")
                    return None
        
                default_user = config['DEFAULT']['default-user']
        
                if default_user not in config:
                    log(f"[ERROR] User profile '{default_user}' not found in {config_file}")
                    return None
        
                token = config[default_user].get('token')
                if not token:
                    log(f"[ERROR] No token found for user '{default_user}' in {config_file}")
                    return None
        
                return token
        
            except Exception as e:
                log(f"[ERROR] Exception while reading configuration file: {str(e)}")
                return None
        
        def fetch_assigned_ips():
            if (
                    VLAN_IP_CACHE["ips"] is not None
                    and VLAN_IP_CACHE["timestamp"] is not None
                    and (datetime.now() - VLAN_IP_CACHE["timestamp"]).total_seconds() < VLAN_IP_CACHE["ttl_seconds"]
            ):
                log("[INFO] Using cached VLAN IPs")
                return VLAN_IP_CACHE["ips"]
        
            LINODE_TOKEN = fetch_linode_token()
            REGION = os.getenv("REGION")
        
            if not REGION:
                log("[ERROR] REGION environment variable not set")
                raise EnvironmentError("REGION environment variable not set")
        
            if not LINODE_TOKEN:
                log("[ERROR] Missing Linode Token")
                return None
        
            headers = {"Authorization": f"Bearer {LINODE_TOKEN}"}
            log(f"[DEBUG] Fetching VLAN IPs for region: {REGION}")
        
            url = "https://api.linode.com/v4/linode/instances"
            instances = api_request_with_retry(url, headers={"Authorization": f"Bearer {LINODE_TOKEN}",
                                                             "X-Filter": f'{{"region": "{REGION}"}}'})
        
            if not instances:
                log("[ERROR] Failed to fetch Linode instances")
                return None
        
            linode_ids = [str(l["id"]) for l in instances.get("data", [])]
            log(f"[DEBUG] Linode IDs fetched: {linode_ids}")
        
            vlan_ips = []
        
            def fetch_configs(linode_id):
                try:
                    log(f"[DEBUG] Fetching VLAN IPs for Linode ID: {linode_id}")
                    config_url = f"https://api.linode.com/v4/linode/instances/{linode_id}/configs"
                    configs = api_request_with_retry(config_url, headers)
                    if not configs:
                        log(f"[ERROR] Failed to fetch configurations for Linode ID {linode_id}")
                        return []
                    linode_vlan_ips = []
                    for config in configs.get("data", []):
                        for iface in config.get("interfaces", []):
                            if iface.get("purpose") == "vlan":
                                ip_address = iface.get("ipam_address")
                                if ip_address:
                                    linode_vlan_ips.append(ip_address)
                                    log(f"[DEBUG] Found VLAN IP: {ip_address}")
                    return linode_vlan_ips
                except Exception as e:
                    log(f"[ERROR] Exception in fetch_configs for Linode ID {linode_id}: {str(e)}")
                    return []
        
            max_workers = int(os.getenv("MAX_WORKERS", 20))
            max_workers = min(max_workers, max(1, len(linode_ids)))
            if max_workers == 1 and len(linode_ids) > 1:
                log(f"[WARN] Only 1 worker thread available with {len(linode_ids)} Linode instances. Possible API rate limiting.")
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                results = executor.map(fetch_configs, linode_ids)
                for result in results:
                    vlan_ips.extend(result)
        
            log(f"[DEBUG] All VLAN IPs in region {REGION}: {vlan_ips}")
        
            VLAN_IP_CACHE["ips"] = vlan_ips
            VLAN_IP_CACHE["timestamp"] = datetime.now()
        
            return vlan_ips
        
        def system_health_check():
            load_avg = os.getloadavg()
            mem = psutil.virtual_memory()
            mem_info = f"Total: {mem.total / (1024 ** 2):.2f} MB, Used: {mem.used / (1024 ** 2):.2f} MB, Free: {mem.free / (1024 ** 2):.2f} MB"
            log(f"[INFO] System Load Average: {load_avg}")
            log(f"[INFO] Memory Information: {mem_info}")
            if load_avg[0] > os.cpu_count() * 2:
                log("[WARN] High system load detected")
                return False
            if mem.percent > 90:
                log("[WARN] High memory usage detected")
                return False
            return True
        
        def get_etcd_connection():
            endpoints = os.getenv("ETCD_ENDPOINTS", "")
            if not endpoints:
                raise EnvironmentError("ETCD_ENDPOINTS not set in environment")
        
            # Try each endpoint until successful
            for ep in endpoints.split(","):
                ep = ep.replace("http://", "").replace("https://", "").rstrip("/")  # Normalize scheme and slashes
        
                parts = ep.split(":")
                if len(parts) != 2:
                    log(f"[ERROR] Invalid ETCD endpoint format: {ep}. Expected format: host:port")
                    continue
        
                host = parts[0]
                try:
                    port = int(parts[1])
                except ValueError:
                    log(f"[ERROR] Port is not a valid integer in endpoint: {ep}")
                    continue
        
                try:
                    client = etcd3.client(host=host, port=port)
                    client.status()  # Health check
                    log(f"[INFO] Connected to etcd: {host}:{port}")
                    return client
                except Exception as e:
                    log(f"[WARN] Failed to connect to etcd endpoint {host}:{port}: {str(e)}")
                    continue
        
            raise ConnectionError("Unable to connect to any etcd endpoint")
        
        
        # =======================
        # üü¢ Allocate IP Endpoint Sandip
        # =======================
        @app.route('/allocate', methods=['POST'])
        def allocate_ip():
            try:
                subnet = request.json.get('subnet')
                if not subnet:
                    log("[ERROR] Subnet not provided")
                    return jsonify({"error": "Subnet not provided"}), 400
        
                REGION = os.getenv("REGION")
                if not REGION:
                    log("[ERROR] Region not provided")
                    return jsonify({"error": "Region not provided"}), 400
        
                log(f"[DEBUG] Subnet: {subnet}, Region: {REGION}")
        
                try:
                    ip_net = ipaddress.ip_network(subnet, strict=False)
                    cidr_suffix = f"/{ip_net.prefixlen}"
                except ValueError:
                    log("[ERROR] Invalid subnet format")
                    return jsonify({"error": "Invalid subnet format"}), 400
        
                # Connect to etcd
                etcd = get_etcd_connection()
                if not etcd:
                    return jsonify({"error": "Unable to connect to etcd"}), 500
        
                # Fetch all IPs already used from etcd
                etcd_used_ips = set()
                for value, meta in etcd.get_prefix("/vlan/ip/"):
                    if meta.key:
                        etcd_used_ips.add(meta.key.decode("utf-8").replace("/vlan/ip/", ""))
        
                log(f"[DEBUG] IPs found in etcd: {etcd_used_ips}")
        
                # ‚úÖ Fetch all Linode-assigned VLAN IPs (even if not in etcd)
                linode_assigned_ips = set(fetch_assigned_ips())
        
                # ‚úÖ Merge both to get full list of used IPs
                used_ips = etcd_used_ips.union(linode_assigned_ips)
        
                # Sync missing IPs into etcd
                missing_in_etcd = linode_assigned_ips - etcd_used_ips
                for ip in missing_in_etcd:
                    try:
                        etcd.put(f"/vlan/ip/{ip}", "true")
                        log(f"[SYNC] Added missing Linode-assigned IP to etcd: {ip}")
                    except Exception as e:
                        log(f"[ERROR] Failed to sync IP {ip} to etcd: {str(e)}")
        
                used_ips = etcd_used_ips.union(linode_assigned_ips)
        
                # Determine reserved IPs
                hosts = list(ip_net.hosts())
                if len(hosts) >= 3:
                    reserved_ips = {
                        str(hosts[0]),
                        str(hosts[1]),
                        str(hosts[-1])
                    }
                else:
                    reserved_ips = set()
        
                skipped_reserved = 0
                attempted_ips = 0
        
                # Begin IP scan
                for ip in hosts:
                    candidate_ip = f"{ip}{cidr_suffix}"
                    attempted_ips += 1
        
                    if candidate_ip in reserved_ips:
                        log(f"[INFO] Skipping Reserved IP: {candidate_ip}")
                        skipped_reserved += 1
                        continue
        
                    if candidate_ip in used_ips:
                        log(f"[INFO] Skipping Already Allocated IP: {candidate_ip}")
                        continue
        
                    try:
                        key = f"/vlan/ip/{candidate_ip}"
                        txn_success, _ = etcd.transaction(
                            compare=[
                                etcd.transactions.version(key) == 0  # Key must not exist
                            ],
                            success=[
                                etcd.transactions.put(key, "true")
                            ],
                            failure=[]
                        )
        
                        if txn_success:
                            log(f"[SUCCESS] Allocated IP: {candidate_ip}")
                            return jsonify({"allocated_ip": candidate_ip}), 200
                        else:
                            log(f"[INFO] Race condition ‚Äî IP was just taken: {candidate_ip}")
                            continue
                    except Exception as e:
                        log(f"[ERROR] etcd put failed for {candidate_ip}: {str(e)}")
                        return jsonify({"error": f"Failed to allocate IP: {str(e)}"}), 500
        
                error_msg = (
                    f"No IPs available in subnet {subnet}. "
                    f"Attempted {attempted_ips} IPs, "
                    f"{skipped_reserved} were reserved, "
                    f"{len(used_ips)} already allocated."
                )
                log(f"[ERROR] {error_msg}")
                return jsonify({"error": error_msg}), 400
        
            except Exception as e:
                log(f"[ERROR] Unexpected error in /allocate endpoint: {str(e)}")
                return jsonify({"error": f"Unexpected error: {str(e)}"}), 500
        
        
        # =======================
        # üî¥ Release IP Endpoint
        # =======================
        @app.route('/release', methods=['POST'])
        def release_ip():
            try:
                ip_address = request.json.get('ip_address')
                if not ip_address:
                    return jsonify({"error": "IP address not provided"}), 400
        
                ip_address = ip_address.strip()
                REGION = os.getenv("REGION")
                SUBNET = os.getenv("SUBNET")
                if not REGION or not SUBNET:
                    return jsonify({"error": "Missing REGION or SUBNET env variable"}), 500
        
                try:
                    ip_net = ipaddress.ip_network(SUBNET, strict=False)
                    cidr_suffix = f"/{ip_net.prefixlen}"
                    hosts = list(ip_net.hosts())
        
                    reserved_ips = set()
                    if len(hosts) >= 3:
                        reserved_ips = {
                            str(hosts[0]),
                            str(hosts[1]),
                            str(hosts[-1])
                        }
        
                    if ip_address in reserved_ips:
                        log(f"[WARN] Attempted to release reserved IP: {ip_address}")
                        return jsonify({"error": f"IP address {ip_address} is reserved and cannot be released."}), 403
        
                    etcd = get_etcd_connection()
                    if not etcd:
                        return jsonify({"error": "Failed to connect to etcd"}), 500
        
                    key = f"/vlan/ip/{ip_address}"
                    deleted = etcd.delete(key)
        
                    if deleted:
                        log(f"[INFO] Released IP from etcd: {ip_address}")
                        return jsonify({"status": "IP released", "ip": ip_address}), 200
                    else:
                        log(f"[WARN] IP {ip_address} not found in etcd")
                        return jsonify({"error": f"IP address {ip_address} not found in etcd"}), 404
        
                except Exception as e:
                    log(f"[ERROR] Release failed: {str(e)}")
                    return jsonify({"error": f"Release failed: {str(e)}"}), 500
        
            except Exception as e:
                log(f"[ERROR] Unexpected error in /release endpoint: {str(e)}")
                return jsonify({"error": f"Unexpected error: {str(e)}"}), 500
        
        # =======================
        # üîµ Health Check Endpoint
        # =======================
        @app.route('/health', methods=['GET'])
        def health_check():
            try:
                linode_token = fetch_linode_token()
                if not linode_token:
                    log("[ERROR] Health check: Failed to validate Linode CLI configuration")
                    return jsonify({"status": "unhealthy", "error": "Invalid Linode CLI configuration"}), 500
        
                headers = {"Authorization": f"Bearer {linode_token}"}
                REGION = os.getenv("REGION")
                if not REGION:
                    log("[ERROR] Health check: REGION environment variable not set")
                    return jsonify({"status": "unhealthy", "error": "REGION environment variable not set"}), 500
        
                start_time = time.time()
                response = requests.get("https://api.linode.com/v4/account", headers=headers, timeout=5)
                end_time = time.time()
                latency_ms = (end_time - start_time) * 1000
                if latency_ms > 200:
                    log(f"[WARN] Linode API latency is high: {latency_ms:.2f} ms")
                if response.status_code == 401:
                    log("[ERROR] Health check: Unauthorized access. Token might be invalid")
                    return jsonify({"status": "unhealthy", "error": "Unauthorized access"}), 500
                if response.status_code != 200:
                    log(f"[ERROR] Health check: Failed to connect to Linode API, status {response.status_code}")
                    return jsonify({"status": "unhealthy", "error": "Failed to connect to Linode API"}), 500
        
                response = requests.get("https://api.linode.com/v4/networking/ips", headers=headers, timeout=5)
                if response.status_code != 200:
                    log(f"[ERROR] Health check: Failed to access networking API, status {response.status_code}")
                    return jsonify({"status": "unhealthy", "error": "Failed to access networking API"}), 500
        
                if (
                        REGION_CACHE["timestamp"] is None
                        or (datetime.now() - REGION_CACHE["timestamp"]).total_seconds() > REGION_CACHE["ttl_seconds"]
                ):
                    response = requests.get(f"https://api.linode.com/v4/regions/{REGION}", headers=headers, timeout=5)
                    if response.status_code != 200:
                        log(f"[ERROR] Health check: Invalid or unavailable region {REGION}, status {response.status_code}")
                        return jsonify({"status": "unhealthy", "error": f"Invalid or unavailable region {REGION}"}), 500
                    REGION_CACHE["valid"] = True
                    REGION_CACHE["timestamp"] = datetime.now()
                elif not REGION_CACHE["valid"]:
                    log(f"[ERROR] Health check: Cached result indicates invalid region {REGION}")
                    return jsonify({"status": "unhealthy", "error": f"Invalid or unavailable region {REGION}"}), 500
                try:
                    etcd = get_etcd_connection()
                    etcd.status()
                except Exception as e:
                    log(f"[ERROR] Health check: Failed to connect to etcd: {str(e)}")
                    return jsonify({"status": "unhealthy", "error": f"etcd connection failed: {str(e)}"}), 500
        
                if not system_health_check():
                    log("[ERROR] Health check: System health checks failed")
                    return jsonify({"status": "unhealthy", "error": "System health checks failed"}), 500
        
                log("[INFO] Health check: All checks passed")
                return jsonify({"status": "healthy", "latency_ms": latency_ms}), 200
        
            except requests.RequestException as e:
                log(f"[ERROR] Health check: Network connectivity error: {str(e)}")
                return jsonify({"status": "unhealthy", "error": f"Network connectivity error: {str(e)}"}), 500
            except Exception as e:
                log(f"[ERROR] Health check: Unexpected error: {str(e)}")
                return jsonify({"status": "unhealthy", "error": f"Unexpected error: {str(e)}"}), 500
        
        # =======================
        # üöÄ Start Flask Application
        # =======================
        if __name__ == '__main__':
            validate_environment()
            app.run(host='0.0.0.0', port=8080, debug=True)
