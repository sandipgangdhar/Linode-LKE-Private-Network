# 04-vlan-manager-scripts-configmap.yaml
# 
# This YAML file defines the ConfigMap for VLAN Manager scripts in Linode LKE.
# It includes the following scripts for IP allocation, release, VLAN attachment,
# and IP list initialization:
# 
# 1️⃣ 02-script-vlan-attach.sh   - Attaches the VLAN to the Linode instance and sets up routing.
# 2️⃣ 03-script-ip-allocate.sh   - Allocates an IP address from the subnet.
# 3️⃣ 04-script-ip-release.sh    - Releases the IP address back to the pool.
# 4️⃣ 05-script-ip-list-initialize.sh - Initializes the IP list from the subnet.
# 5️⃣ 06-rest-api.py             - REST API to manage IP allocation and release.
# 
# -----------------------------------------------------
# 📝 Parameters:
# 
# 1️⃣ SUBNET            - Subnet for IP allocation.
# 2️⃣ ROUTE_IP          - Gateway IP for the primary subnet.
# 3️⃣ VLAN_LABEL        - VLAN identifier for Linode.
# 4️⃣ DEST_SUBNET       - Destination subnet for routing.
# 5️⃣ API_ENDPOINT      - URL for IP allocation and release.
# 
# -----------------------------------------------------
# 🔄 Usage:
# 
# - These scripts are mounted into the VLAN Manager Pod and executed during
#   VLAN attachment, IP allocation, and IP release processes.
# - Communication is handled through the configured API endpoints.
# 
# -----------------------------------------------------
# 📌 Best Practices:
# 
# - Ensure the VLAN label and subnet are correctly configured before running.
# - Monitor logs for connectivity issues during VLAN attachment.
# - Use health checks to validate API availability before IP allocation.
# 
# -----------------------------------------------------
# 🖋️ Author:
# - Sandip Gangdhar
# - GitHub: https://github.com/sandipgangdhar
# 
# © Linode-LKE-Private-Network | Developed by Sandip Gangdhar | 2025
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vlan-manager-scripts
  namespace: kube-system
data:
  02-script-vlan-attach.sh: |
        #!/bin/bash
        set -e
        
        # === Environment Variables ===
        # These variables are populated from Kubernetes ConfigMap or environment
        SUBNET="${SUBNET}"
        export ROUTE_LIST="${ROUTE_LIST:-}"
        VLAN_LABEL="${VLAN_LABEL}"
        DEST_SUBNET="${DEST_SUBNET}"
        ENABLE_PUSH_ROUTE="$(echo "$ENABLE_PUSH_ROUTE" | tr '[:upper:]' '[:lower:]')"  # flag to control route pushing
        ENABLE_FIREWALL="$(echo "$ENABLE_FIREWALL" | tr '[:upper:]' '[:lower:]')" # flag to control FIREWALL Creation and attachment
        LKE_CLUSTER_ID="${LKE_CLUSTER_ID}"
        
        # === Function to Log Events ===
        # This function logs events with a timestamp
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        log "🔄 Starting VLAN Attachment Script..."
        
        # Wait for DNS to resolve
        function wait_for_dns() {
            while ! nslookup api.linode.com >/dev/null 2>&1; do
                log "🌐 DNS resolution failed. Retrying in 10 seconds..."
                sleep 10
            done
            log "✅ DNS resolution successful."
        }
        
        # 🧼 Cleanup old CoreDNS reboot lock if held by this node
        REBOOT_LOCK_KEY="/coredns-reboot-lock"
        CURRENT_NODE=$(hostname)
        if [ -n "$ETCD_ENDPOINTS" ]; then
            # Wait for etcd DNS to resolve
            until nslookup etcd-0.etcd.kube-system.svc.cluster.local >/dev/null 2>&1; do
                log "🌐 Waiting for DNS to resolve etcd-0 during lock cleanup..."
                sleep 5
            done
        
            # Check and delete the lock if this node owns it
            LOCK_OWNER=$(etcdctl --endpoints "$ETCD_ENDPOINTS" get "$REBOOT_LOCK_KEY" --print-value-only 2>/dev/null)
            if [[ "$LOCK_OWNER" == "$CURRENT_NODE" ]]; then
                etcdctl --endpoints "$ETCD_ENDPOINTS" del "$REBOOT_LOCK_KEY"
                log "🧹 Removed stale CoreDNS reboot lock held by $CURRENT_NODE"
            fi
        fi
        
        # === Function to check if VLAN is already attached ===
        is_vlan_attached() {
            wait_for_dns ⏳ Ensure DNS is up before calling Linode API
            VLAN_STATUS=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].purpose // empty')
            if [ "$VLAN_STATUS" == "vlan" ]; then
                return 0
            else
                return 1
            fi
        }
        
        # Function: Detect Configured-But-Missing VLAN Interface and Trigger Reboot
        function handle_vlan_configured_but_missing_interface() {
            set +e
            wait_for_dns
            VLAN_ATTACHED=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].purpose // empty')
            set -e
        
            if [[ "$VLAN_ATTACHED" == "vlan" ]]; then
                set +e
                wait_for_dns
                VLAN_IP=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].ipam_address // empty')
                set -e
                wait_for_dns
                VLAN_INTERFACE=$(ip -o addr show | grep "$VLAN_IP" | awk '{print $2}' | head -n1)
        
                if [[ -z "$VLAN_INTERFACE" ]]; then
                    log "⚠️ VLAN is attached in config but the interface is missing. Reboot is likely pending from previous run."
        
                    CURRENT_NODE=$(hostname)
                    REBOOT_LOCK_KEY="/coredns-reboot-lock"
                    ETCD_URL="http://etcd-0.etcd.kube-system.svc.cluster.local:2379"
        
                    log "🔍 Checking if this node is hosting a CoreDNS pod..."
                    set +e
                    COREDNS_HOST=$(kubectl get pods -n kube-system -o json | jq -r \
                        '.items[] | select(.metadata.labels["k8s-app"] == "kube-dns") | .spec.nodeName' \
                        | grep -w "$CURRENT_NODE")
                    KUBE_EXIT=$?
                    set -e
        
                    if [[ "$KUBE_EXIT" -ne 0 || -z "$COREDNS_HOST" ]]; then
                        log "🚀 This node is NOT hosting a CoreDNS pod. Rebooting immediately..."
                    else
                        log "🧠 $CURRENT_NODE is hosting a CoreDNS pod. Serialized reboot enabled."
        
                        ACQUIRED=false
                        while [[ "$ACQUIRED" != true ]]; do
                            until nslookup etcd-0.etcd.kube-system.svc.cluster.local >/dev/null 2>&1; do
                                log "🌐 Waiting for DNS to resolve etcd-0..."
                                sleep 5
                            done
        
                            log "🔒 Attempting atomic lock via etcd transaction..."
        
                            TXN_PAYLOAD=$(cat <<EOF
        {
          "compare": [
            {
              "key": "$(echo -n "$REBOOT_LOCK_KEY" | base64)",
              "target": "VERSION",
              "result": "EQUAL",
              "version": "0"
            }
          ],
          "success": [
            {
              "requestPut": {
                "key": "$(echo -n "$REBOOT_LOCK_KEY" | base64)",
                "value": "$(echo -n "$CURRENT_NODE" | base64)"
              }
            }
          ],
          "failure": [
            {
              "requestRange": {
                "key": "$(echo -n "$REBOOT_LOCK_KEY" | base64)"
              }
            }
          ]
        }
        EOF
        )
        
                            RESPONSE=$(curl -s -X POST "$ETCD_URL/v3/kv/txn" \
                                -H "Content-Type: application/json" \
                                -d "$TXN_PAYLOAD")
        
                            if echo "$RESPONSE" | grep -q '"succeeded":true'; then
                                log "✅ Lock acquired by $CURRENT_NODE for CoreDNS reboot."
                                ACQUIRED=true
                            else
                                HOLDER=$(echo "$RESPONSE" | jq -r '.responses[0].response_range.kvs[0].value' | base64 -d)
                                log "⛔ Lock held by $HOLDER. Waiting 10s before retry..."
                                sleep 10
                            fi
                        done
                    fi
        
                    # === Reboot logic ===
                    log "🔁 Initiating reboot via Linode CLI to apply VLAN changes..."
                    RETRY=0
                    MAX_RETRIES=10
        
                    while true; do
                        set +e
                        wait_for_dns
                        linode-cli linodes reboot "$LINODE_ID"
                        EXIT_CODE=$?
                        set -e
        
                        if [[ "$EXIT_CODE" -eq 0 ]]; then
                            log "✅ Reboot command succeeded."
                            break
                        else
                            log "⚠️ Reboot failed (possibly Linode busy). Retrying in 5s... ($((RETRY+1))/$MAX_RETRIES)"
                            RETRY=$((RETRY + 1))
                            if [[ $RETRY -ge $MAX_RETRIES ]]; then
                                log "❌ Reboot failed after $MAX_RETRIES attempts. Sleeping indefinitely."
                                sleep infinity
                            fi
                            sleep 5
                        fi
                    done
        
                    sleep 300
                    log "⚠️ Node did not reboot as expected. Sleeping to avoid loop."
                    sleep infinity
                fi
            fi
        }
        
        # === Function to push the route ===
        push_route() {
            if [[ "$ENABLE_PUSH_ROUTE" == "true" ]]; then
                echo "📦 Parsing ROUTE_LIST from ConfigMap..."
                # 🌐 Check if any DEST_SUBNET is 172.17.0.0/16 and delete default Docker route if needed
                log "🔍 Scanning ROUTE_LIST to see if 172.17.0.0/16 is present..."
        
                if echo "$ROUTE_LIST" | grep -q 'dest_subnet: "172.17.0.0/16"'; then
                    log "⚠️ Found route for 172.17.0.0/16 in ROUTE_LIST. Checking and deleting LKE Docker route if exists..."
        
                    set +e
                    ip route show | grep -q "^172.17.0.0/16.*docker0"
                    DEFAULT_LKE_ROUTE_STATUS=$?
                    set -e
        
                    if [ $DEFAULT_LKE_ROUTE_STATUS -eq 0 ]; then
                        set +e
                        ip route delete 172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1
                        DELETE_STATUS=$?
                        set -e
        
                        if [ $DELETE_STATUS -eq 0 ]; then
                            log "✅ Default LKE Docker Route for 172.17.0.0/16 successfully deleted"
                        else
                            log "⚠️ Failed to delete LKE Docker route for 172.17.0.0/16. Please verify manually."
                        fi
                    else
                        log "✅ No LKE Docker route for 172.17.0.0/16 found. Nothing to delete."
                    fi
                else
                    log "✅ ROUTE_LIST does not contain 172.17.0.0/16. Skipping Docker route check."
                fi
        
                echo "$ROUTE_LIST" | while read -r line; do
                    if [[ "$line" =~ route_ip ]]; then
                        ROUTE_IP=$(echo "$line" | awk -F': ' '{print $2}' | tr -d '"')
                    elif [[ "$line" =~ dest_subnet ]]; then
                        DEST_SUBNET=$(echo "$line" | awk -F': ' '{print $2}' | tr -d '"')
        
                        if [[ -z "$ROUTE_IP" || "$ROUTE_IP" == "0.0.0.0" || -z "$DEST_SUBNET" || "$DEST_SUBNET" == "0.0.0.0/0" ]]; then
                            log "❌ ENABLE_PUSH_ROUTE is true, but ROUTE_IP or DEST_SUBNET is unset or invalid."
                            log "🛑 Skipping route push and sleeping indefinitely to avoid container crash loop."
                            sleep infinity
                        fi
                        log "🔁 Processing Route: $DEST_SUBNET via $ROUTE_IP"
                        log "📦 ENABLE_PUSH_ROUTE: $ENABLE_PUSH_ROUTE"
                        log "📦 ROUTE_IP: $ROUTE_IP"
                        log "📦 DEST_SUBNET: $DEST_SUBNET"
        
                        log "Checking the VLAN_INTERFACE..."
                        # Extract the VLAN IP
                        wait_for_dns ⏳ Ensure DNS is up before calling Linode API
                        VLAN_IP=$(linode-cli linodes config-view "$LINODE_ID" "$CONFIG_ID" --json | jq -r '.[0].interfaces[1].ipam_address // empty')
        
                        # Extract the IP portion (strip subnet)
                        VLAN_IP_ADDR=$(echo "$VLAN_IP" | cut -d'/' -f1)
                        log "VLAN IP is $VLAN_IP_ADDR..."
                        VLAN_INTERFACE=$(ip -o addr | awk -v ip="$VLAN_IP_ADDR" '$0 ~ ip {print $2; exit}')
                        log "📦 VLAN interface value is: $VLAN_INTERFACE"
        
                        if [[ -z "$VLAN_INTERFACE" ]]; then
                            log "❌ Could not resolve VLAN interface for IP $VLAN_IP. Sleeping indefinitely..."
                            sleep infinity
                        fi
        
                        log "📦 ENABLE_PUSH_ROUTE value is: $ENABLE_PUSH_ROUTE"
                        log "📦 ROUTE_IP value is: $ROUTE_IP"
                        log "📦 DEST_SUBNET value is: $DEST_SUBNET"
        
                        log "Checking if route already exists for $DEST_SUBNET..."
                        set +e
                        ip route show | grep -q "$DEST_SUBNET"
                        STATUS=$?
                        set -e
        
                        if [ $STATUS -eq 0 ]; then
                            log "✅ Route $DEST_SUBNET already exists. Skipping addition."
                        else
                            log "⚙️  Adding route $DEST_SUBNET via $ROUTE_IP on $VLAN_INTERFACE..."
                            set +e
                            ip route add "$DEST_SUBNET" via "$ROUTE_IP" dev $VLAN_INTERFACE
                            ADD_STATUS=$?
                            set -e
        
                            if [ $ADD_STATUS -eq 0 ]; then
                                log "✅ Route $DEST_SUBNET via $ROUTE_IP successfully added to eth1."
                            else
                                log "⚠️  Failed to add route $DEST_SUBNET via $ROUTE_IP. It may already exist."
                            fi
                        fi
                    fi  
                done   
            else
                log "ℹ️ Skipping route push as ENABLE_PUSH_ROUTE is set to false."
            fi
        }
        
        # === Function to create and attach firewall ===
        create_and_attach_firewall() {
            if [[ "$ENABLE_FIREWALL" != "true" ]]; then
                log "ℹ️ Skipping firewall creation as ENABLE_FIREWALL is set to false."
                return 0
            fi
        
            FIREWALL_LABEL="lke-cluster-firewall-${LKE_CLUSTER_ID}"
            log "🔍 Checking if firewall '$FIREWALL_LABEL' already exists..."
        
            set +e
            wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
            FIREWALL_ID=$(linode-cli firewalls list --json 2>/dev/null | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
            set -e
        
            if [[ -z "$FIREWALL_ID" ]]; then
                log "🚀 Creating new firewall with label $FIREWALL_LABEL..."
                set +e
                wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
                CREATE_OUTPUT=$(linode-cli firewalls create \
                  --label "$FIREWALL_LABEL" \
                  --rules.inbound='[
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "10250,10256", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Kubelet_Health_Checks"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "51820", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "kubectl_proxy_Wireguard_tunnel"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "53", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "TCP_cluster_DNS_access"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "53", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "UDP_cluster_DNS_access"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "179", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Calico_BGP_traffic"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "5473", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "Calico_Typha_traffic"},
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "30000-32767", "addresses": { "ipv4": ["192.168.255.0/24"] }, "label": "NodeBalancer_TCP"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "30000-32767", "addresses": { "ipv4": ["192.168.255.0/24"] }, "label": "NodeBalancer_UDP"},
                    {"action": "ACCEPT", "protocol": "IPENCAP", "addresses": { "ipv4": ["192.168.128.0/17"] }, "label": "NP_CP_communication"}
                  ]' \
                  --rules.outbound='[
                    {"action": "ACCEPT", "protocol": "TCP", "ports": "1-65535", "addresses": { "ipv4": ["0.0.0.0/0"] }, "label": "Allow_All_TCP_Outbound"},
                    {"action": "ACCEPT", "protocol": "UDP", "ports": "1-65535", "addresses": { "ipv4": ["0.0.0.0/0"] }, "label": "Allow_All_UDP_Outbound"}
                  ]' \
                  --rules.inbound_policy="DROP" \
                  --rules.outbound_policy="ACCEPT" \
                  --json)
                CREATE_STATUS=$?
                set -e
        
                if [[ $CREATE_STATUS -ne 0 || -z "$CREATE_OUTPUT" ]]; then
                    log "⚠️ Firewall creation failed, checking if it was created by another node..."
                    log "⚠️ First let's give 60 sec to Linode for creation...."
                    sleep 60
                    set +e
                    wait_for_dns # ⏳ Ensure DNS is up before calling Linode AP
                    FIREWALL_ID=$(linode-cli firewalls list --json | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
                    set -e
                    if [[ -z "$FIREWALL_ID" ]]; then
                        log "❌ Firewall creation failed and it does not exist. Sleeping indefinitely."
                        sleep infinity
                    else
                        log "✅ Firewall was created by another process. Continuing with ID $FIREWALL_ID"
                    fi
                else
                    wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
                    FIREWALL_ID=$(linode-cli firewalls list --json | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
                    log "✅ Firewall created with ID $FIREWALL_ID"
                fi
                wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
                FIREWALL_ID=$(linode-cli firewalls list --json | jq -r ".[] | select(.label==\"$FIREWALL_LABEL\") | .id")
                log "✅ Firewall created with ID $FIREWALL_ID"
            else
                log "✅ Firewall $FIREWALL_LABEL already exists with ID $FIREWALL_ID"
            fi
        
            # Check if any firewall is already attached to this Linode
            log "🔍 Verifying if Linode ID $LINODE_ID already has any firewall attached..."
            wait_for_dns ⏳ Ensure DNS is up before calling Linode API
            FIREWALLS_WITH_ENTITIES=$(linode-cli firewalls list --json | jq -r '.[] | select(.entities != null) | @base64')
            for fw in $FIREWALLS_WITH_ENTITIES; do
                _jq() { echo "$fw" | base64 --decode | jq -r "$1"; }
                FW_ID=$(_jq '.id')
                wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
                ENTITY_IDS=$(linode-cli firewalls view "$FW_ID" --json | jq -r '.[0].entities[]?.id')
                for id in $ENTITY_IDS; do
                    if [[ "$id" == "$LINODE_ID" ]]; then
                        log "⚠️ Linode ID $LINODE_ID already has a firewall attached (Firewall ID: $FW_ID). Skipping attachment."
                        return 0
                    fi
                done
            done
        
            log "🔗 Attaching firewall $FIREWALL_LABEL to Linode instance $LINODE_ID..."
            set +e
            wait_for_dns ⏳ Ensure DNS is up before calling Linode API
            linode-cli firewalls device-create "$FIREWALL_ID" --type linode --id "$LINODE_ID"
            ATTACH_STATUS=$?
            set -e
        
            if [[ $ATTACH_STATUS -eq 0 ]]; then
                # Wait for firewall to be fully attached before proceeding
                ATTACH_WAIT_RETRIES=10
                ATTACH_WAIT_DELAY=5
                ATTACH_CONFIRMED=false
                for i in $(seq 1 $ATTACH_WAIT_RETRIES); do
                    set +e
                    wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
                    linode-cli firewalls devices-list "$FIREWALL_ID" --json | jq --argjson lid "$LINODE_ID" -e '.[] | select(.entity.id == $lid)' > /dev/null
                    FIREWALL_DEVICE_STATUS=$?
                    set -e
                    if [[ "$FIREWALL_DEVICE_STATUS" -eq 0 ]]; then
                        ATTACH_CONFIRMED=true
                        log "✅ Firewall successfully attached to Linode ID $LINODE_ID"
                        log "🛡️ Firewall ENABLED – Firewall '$FIREWALL_LABEL' (ID: $FIREWALL_ID) successfully created/attached to instance."
                        log "✅ Firewall attachment complete. Continuing to finalize script execution..."
                        break
                    else
                        log "⏳ Waiting for firewall to attach (attempt $i/$ATTACH_WAIT_RETRIES)..."
                        sleep "$ATTACH_WAIT_DELAY"
                    fi
                done
                if [[ "$ATTACH_CONFIRMED" != true ]]; then
                    log "❌ Firewall did not attach within expected time for Linode ID $LINODE_ID"
                    sleep infinity
                fi
            else
                log "❌ Failed to attach firewall to Linode ID $LINODE_ID. Sleeping indefinitely to avoid container restart loop."
                sleep infinity
            fi
        }
        
        
        # === Discover Node IP and Name ===
        # Retrieve the IP address of eth0 (assumed to be the main interface)
        log "🌐 Fetching NODE IP of the instance..."
        NODE_IP=$(ip addr show eth0 | grep -v "eth0:[0-9]" | grep -w inet | awk {'print $2'}|awk -F'/' {'print $1'})
        
        log "🌐 Node IP: $NODE_IP"
        
        # Query Kubernetes to find the node name associated with this IP
        log "🌐 Fetching NODE NAME of the instance..."
        NODE_NAME=$(kubectl get nodes -o json | jq -r '.items[] | select(.status.addresses[]?.address == "'"$NODE_IP"'") | .metadata.name')
        
        log "🌐 Node Name: $NODE_NAME"
        
        # === Fetch Public IP of the Node ===
        # This fetches the public IP associated with the node from the Kubernetes API
        log "🌐 Fetching Public IP of the instance..."
        PUBLIC_IP=$(kubectl get node $NODE_NAME -o jsonpath='{.status.addresses[?(@.type=="ExternalIP")].address}' | awk {'print $1'})
        log "🌐 Public IP of the Node: $PUBLIC_IP"
        
        export LINODE_CLI_CONFIG="/root/.linode-cli/linode-cli"
        
        # === Discover Linode ID and Configuration ID ===
        # Linode API calls to find the instance ID and its configuration ID

        # Linode API calls to find the instance ID and its configuration ID
        LINODE_ID=""
        TARGET_IP="$PUBLIC_IP"
        
        # Step 1: Fetch page 1 and extract total pages from CLI output
        log "📄 Fetching page 1 to detect total number of pages..."
        PAGE_OUTPUT=$(linode-cli linodes list --page 1 --page-size 100)
        HEADER_LINE=$(echo "$PAGE_OUTPUT" | tail -n 1)
        TOTAL_PAGES=$(echo "$HEADER_LINE" | grep -oP 'Page 1 of \K[0-9]+')
        
        # Fallback in case parsing fails
        if [[ -z "$TOTAL_PAGES" ]]; then
            TOTAL_PAGES=1
            log "⚠️ Could not determine total pages. Defaulting to 1."
        fi
        
        log "📄 Total Pages Detected: $TOTAL_PAGES"
        
        # Step 2: Loop over the actual number of pages
        for page in $(seq 1 $TOTAL_PAGES); do
            log "🔍 Searching Linode list: Page $page"
            wait_for_dns
        
            result=$(linode-cli linodes list --page $page --page-size 100 --json)
            LINODE_ID=$(echo "$result" | jq -r --arg ip "$TARGET_IP" '.[] | select(.ipv4[]? == $ip) | .id')
        
            if [[ -n "$LINODE_ID" ]]; then
                log "✅ Found Linode with IP $TARGET_IP. LINODE_ID: $LINODE_ID"
                break
            fi
        done
        
        # Final check
        if [[ -z "$LINODE_ID" ]]; then
            log "❌ Failed to find Linode with public IP $TARGET_IP in $TOTAL_PAGES pages."
            exit 1
        fi

        wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
        CONFIG_ID=$(linode-cli linodes configs-list $LINODE_ID --json | jq -r '.[0].id')
        
        # Checking If the Linode ID or Config ID is found Correctly, retry after 60 seconds
        MATCH_COUNT=$(echo "$LINODE_ID" | wc -w)
        if [[ "$MATCH_COUNT" -ne 1 ]]; then
            log "❌ Ambiguous or no Linode match found for IP $PUBLIC_IP (Count: $MATCH_COUNT). Aborting."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 1
        fi
        
        # If either the Linode ID or Config ID is not found, retry after 60 seconds
        if [ -z "$LINODE_ID" ] || [ -z "$CONFIG_ID" ]; then
            log "❌ Failed to retrieve Linode ID or Config ID. Sleeping for 60 seconds and retrying..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        log "✅ Linode ID: $LINODE_ID, Config ID: $CONFIG_ID"
        
        # === Main Logic ===
        handle_vlan_configured_but_missing_interface
        log "🔎 Checking if VLAN is already attached to Linode instance $LINODE_ID..."
        if is_vlan_attached; then
            log "✅ VLAN is already attached. Skipping VLAN configuration and directly pushing the route."
            push_route
            create_and_attach_firewall
            log "🛌 VLAN configuration complete. Sleeping indefinitely..."
            sleep infinity
        fi
        
        # === VLAN Configuration Logic with Retry ===
        log "❌ VLAN is not attached. Proceeding with VLAN configuration..."
        MAX_RETRIES=5
        RETRY_COUNT=0
        SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            log "🔄 Attempting to allocate IP address... (Attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
        
            set +e
            IP_ADDRESS1=$(/tmp/03-script-ip-allocate.sh $SUBNET)
            STATUS=$?
            set -e
        
            if [ $STATUS -eq 0 ]; then
                IP_ADDRESS=$(echo $IP_ADDRESS1 | awk {'print $NF'})
                if [ -n "$IP_ADDRESS" ]; then
                    log "✅ Allocated IP address: $IP_ADDRESS"
                    SUCCESS=true
                    break
                else
                    log "⚠️  No IP address found in response. Retrying..."
                fi
            else
                log "❌ IP allocation script failed. Retrying..."
            fi
        
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 5
        done
        
        if [ "$SUCCESS" = false ]; then
            log "❌ IP allocation failed after $MAX_RETRIES attempts. Retrying in 60 seconds..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 0
        fi
        
        # === Build VLAN JSON ===
        log "⚙️  Building VLAN attachment JSON..."
        INTERFACES_JSON=$(jq -n --arg ip "$IP_ADDRESS" --arg vlan "$VLAN_LABEL" '
            [
              { "type": "public", "purpose": "public" },
              { "type": "vlan", "label": $vlan, "purpose": "vlan", "ipam_address": $ip }
            ]
        ')
        echo $INTERFACES_JSON | jq .
        
        # === Attach the VLAN interface ===
        log "⚙️  Attaching VLAN interface to Linode instance..."
        wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
        linode-cli linodes config-update "$LINODE_ID" "$CONFIG_ID" --interfaces "$INTERFACES_JSON" --label "Boot Config"
        
        # === Check VLAN is attached after attachment and firewall ===
        if is_vlan_attached; then
            log "✅ VLAN is successfully attached now. Proceeding to reboot for changes to take effect..."
        
            touch /tmp/rebooting
        
            REBOOT_LOCK_KEY="/coredns-reboot-lock"
            CURRENT_NODE=$(hostname)
            export ETCDCTL_API=3
        
            if [ -z "$ETCD_ENDPOINTS" ]; then
                log "❌ ETCD_ENDPOINTS not set. Aborting reboot!"
                sleep infinity
            fi
        
            log "🔍 Checking if this node is hosting a CoreDNS pod..."
            set +e
            COREDNS_HOST=$(kubectl get pods -n kube-system -o json | jq -r \
                '.items[] | select(.metadata.labels["k8s-app"] == "kube-dns") | .spec.nodeName' \
                | grep -w "$CURRENT_NODE")
            KUBE_EXIT=$?
            set -e
        
            if [[ "$KUBE_EXIT" -ne 0 ]]; then
                log "⚠️ Failed to fetch CoreDNS pod status. Assuming no CoreDNS on this node. Proceeding with immediate reboot."
            fi
        
            if [[ -n "$COREDNS_HOST" ]]; then
                log "🧠 $CURRENT_NODE is hosting a CoreDNS pod. Serialized reboot enabled."
        
                ACQUIRED=false
                while [[ "$ACQUIRED" != true ]]; do
                    until nslookup etcd-0.etcd.kube-system.svc.cluster.local >/dev/null 2>&1; do
                        log "🌐 Waiting for DNS to resolve etcd-0..."
                        sleep 5
                    done
        
                    log "🔒 Attempting atomic lock via etcd transaction..."
        
                    BASE64_KEY=$(echo -n "$REBOOT_LOCK_KEY" | base64)
                    BASE64_NODE=$(echo -n "$CURRENT_NODE" | base64)
        
                    TXN_PAYLOAD=$(cat <<EOF
        {
          "compare": [
            {
              "key": "$BASE64_KEY",
              "target": "VERSION",
              "result": "EQUAL",
              "version": "0"
            }
          ],
          "success": [
            {
              "requestPut": {
                "key": "$BASE64_KEY",
                "value": "$BASE64_NODE"
              }
            }
          ],
          "failure": [
            {
              "requestRange": {
                "key": "$BASE64_KEY"
              }
            }
          ]
        }
        EOF
        )
        
                    RESPONSE=$(curl -s -X POST "http://etcd-0.etcd.kube-system.svc.cluster.local:2379/v3/kv/txn" \
                      -H "Content-Type: application/json" \
                      -d "$TXN_PAYLOAD")
        
                    if echo "$RESPONSE" | grep -q '"succeeded":true'; then
                        log "✅ Lock acquired by $CURRENT_NODE for CoreDNS reboot."
                        ACQUIRED=true
                    else
                        HOLDER=$(echo "$RESPONSE" | jq -r '.responses[0].response_range.kvs[0].value' | base64 -d)
                        log "⛔ Lock held by $HOLDER. Waiting 10s before retry..."
                        sleep 10
                    fi
                done
            else
                log "🚀 This node is NOT hosting a CoreDNS pod. Rebooting immediately..."
            fi
        
            # === Reboot logic ===
            log "🔁 Initiating reboot via Linode CLI..."
            RETRY=0
            MAX_RETRIES=10
        
            while true; do
                set +e
                wait_for_dns # ⏳ Ensure DNS is up before calling Linode API
                linode-cli linodes reboot "$LINODE_ID"
                EXIT_CODE=$?
                set -e
        
                if [[ "$EXIT_CODE" -eq 0 ]]; then
                    log "✅ Reboot command succeeded."
                    break
                else
                    log "⚠️ Reboot failed (possibly Linode busy). Retrying in 5s... ($((RETRY+1))/$MAX_RETRIES)"
                    RETRY=$((RETRY + 1))
                    if [[ $RETRY -ge $MAX_RETRIES ]]; then
                        log "❌ Reboot failed after $MAX_RETRIES attempts. Sleeping indefinitely."
                        sleep infinity
                    fi
                    sleep 5
                fi
            done
        
            sleep 300
            log "⚠️ Node did not reboot as expected. Sleeping to avoid loop."
            sleep infinity
        else
            log "❌ VLAN check failed after config. Retrying in 60s..."
            sleep 60
            /tmp/02-script-vlan-attach.sh
            exit 1
        fi
        
        # === Cleanup Logic ===
        cleanup() {
            if [ -f "/tmp/rebooting" ]; then
                log "Skipping IP release due to planned reboot."
                rm -rfv /tmp/rebooting
            else
                log "Releasing IP address $IP_ADDRESS..."
                /tmp/04-script-ip-release.sh "$IP_ADDRESS"
                log "IP address $IP_ADDRESS released."
            fi
        }
        trap cleanup EXIT
        
        log "✅ VLAN Attachment completed successfully."
        log "🌐 Instance $LINODE_ID is now connected to VLAN $VLAN_LABEL with IP $IP_ADDRESS."
        log "🟢 VLAN and Firewall configuration steps completed successfully."
        log "🛌 Script execution complete. Sleeping indefinitely..."
        sleep infinity

  03-script-ip-allocate.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP allocation
        API_ENDPOINT="http://vlan-ip-controller-service.kube-system.svc.cluster.local:8080/allocate"
        SUBNET=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$SUBNET" ]; then
            error "No subnet provided for IP allocation."
        fi
        
        log "Requesting IP from API at $API_ENDPOINT for Subnet: $SUBNET..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT \
            -H "Content-Type: application/json" \
            -d "{\"subnet\": \"$SUBNET\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            ALLOCATED_IP=$(echo $RESPONSE_BODY | jq -r '.allocated_ip')
            log "Successfully allocated IP: $ALLOCATED_IP"
            echo $ALLOCATED_IP
        else
            case $HTTP_CODE in
                404)
                    error "API Endpoint not found. Service 'vlan-leader-service' may not be running in namespace 'kube-system'."
                    ;;
                500)
                    error "No IP addresses available in the provided subnet."
                    ;;
                400)
                    error "Bad request. The subnet format is incorrect."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi  
      
  04-script-ip-release.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        # API Endpoint for IP release
        API_ENDPOINT="http://vlan-ip-controller-service.kube-system.svc.cluster.local:8080/release"
        IP_ADDRESS=$1
        
        # Logging function
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        error() {
            echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1"
            exit 1
        }
        
        # === Main Logic ===
        if [ -z "$IP_ADDRESS" ]; then
            error "No IP address provided for release."
        fi
        
        log "Requesting IP release from API at $API_ENDPOINT for IP: $IP_ADDRESS..."
        
        # Execute the curl command and capture response and status code
        RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/response_body.txt -X POST $API_ENDPOINT -H "Content-Type: application/json" -d "{\"ip_address\": \"$IP_ADDRESS\"}")
        HTTP_CODE="${RESPONSE: -3}"
        RESPONSE_BODY=$(cat /tmp/response_body.txt)
        
        # Evaluate the response
        if [ "$HTTP_CODE" == "200" ]; then
            log "Successfully released IP: $IP_ADDRESS"
            echo $IP_ADDRESS
        else
            case $HTTP_CODE in
                404)
                    error "IP address $IP_ADDRESS not found in the allocation list."
                    ;;
                400)
                    error "Bad request. Possibly malformed JSON or missing IP address."
                    ;;
                000)
                    error "Cannot reach the API. Possible DNS issue or service is down."
                    ;;
                *)
                    error "Unexpected error (HTTP $HTTP_CODE) from API: $RESPONSE_BODY"
                    ;;
            esac
        fi
        
  05-script-ip-list-initialize.sh: |
        #!/bin/bash
        # Exit on error
        set -e
        
        #!/bin/bash
        # Exit on error
        set -e
        
        # --- Define Color Codes ---
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[1;34m'
        NC='\033[0m' # No Color
        
        LINODE_TOKEN="${LINODE_TOKEN}"
        #LINODE_TOKEN=`grep token /root/.linode-cli/linode-cli | awk -F'= ' {'print $2'}`
        OUTPUT_FILE="/tmp/vlan-ip-list.txt"
        PAGE_SIZE=100
        CURRENT_PAGE=1
        TOTAL_PAGES=1
        MAX_RETRIES=3
        BACKOFF_BASE=2
        INITIAL_JOBS=5
        MAX_JOBS=20
        
        # === Environment Variables ===
        # File path for IP list storage
        IP_FILE_PATH=$OUTPUT_FILE
        
        # Subnet is passed as the first argument
        SUBNET=$1
        REGION=$2
        
        # === Function to Log Events ===
        # This function logs events with timestamps for better traceability
        log() {
            echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $1"
        }
        
        # === Validate Subnet is Provided ===
        # If the subnet is not passed as an argument, exit with an error
        log "[DEBUG] Script received SUBNET=$SUBNET REGION=$REGION"
        if [ -z "$SUBNET" ]; then
            log "[ERROR] No subnet provided for initialization."
            exit 1
        fi
        
        # === Validate if Region is Provided ===
        # If the region is not passed as an argument, exit with an error
        if [ -z "$REGION" ]; then
            log "[ERROR] No REGION provided for initialization."
            exit 1
        fi
        
        log "🔄 Starting IP List Initialization..."
        
        log "🌐 Subnet provided for initialization: $SUBNET"
        
        # --- Retry Logic Wrapper with Intelligent Backoff and 404 Handling ---
        retry_curl() {
            local URL=$1
            local OUTPUT=$2
            local RETRY_COUNT=0
            local BACKOFF=1
            local SUCCESS=false
        
            while [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
                echo -e "${BLUE}🌐 Attempting API call: $URL (Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)${NC}"
                
                START_TIME=$(date +%s)  # Start timer
        
                if [[ "$URL" == *"/linode/instances/"*"/configs" ]]; then
                    HTTP_CODE=$(curl -s -w "%{http_code}" -H "Authorization: Bearer $LINODE_TOKEN" \
                                "$URL" -o "$OUTPUT")
                else
                    HTTP_CODE=$(curl -s -w "%{http_code}" -H "Authorization: Bearer $LINODE_TOKEN" \
                                -H 'X-Filter: {"region": "'$REGION'"}' \
                                "$URL" -o "$OUTPUT")
                fi
        
                END_TIME=$(date +%s)    # End timer
                DURATION=$((END_TIME - START_TIME))
                echo "$URL | $DURATION ms" >> latency-log.txt
        
                case "$HTTP_CODE" in
                    200)
                        if [ -s "$OUTPUT" ]; then
                            SUCCESS=true
                            echo -e "${GREEN}✅ API call successful ($DURATION ms): $URL${NC}"
                            break
                        fi
                        ;;
                    404)
                        echo -e "${RED}❌ [404] Resource not found: $URL${NC}" | tee -a error-log.txt
                        echo -e "${YELLOW}   ➡️  Skipping further retries for this resource.${NC}"
                        return 1
                        ;;
                    429)
                        echo -e "${YELLOW}⚠️ Rate limit hit. Backing off for $BACKOFF seconds...${NC}"
                        sleep "$BACKOFF"
                        BACKOFF=$((BACKOFF * BACKOFF_BASE))
                        ;;
                    *)
                        echo -e "${RED}⚠️ API call failed with HTTP Code $HTTP_CODE, retrying in $BACKOFF seconds...${NC}"
                        sleep "$BACKOFF"
                        BACKOFF=$((BACKOFF * BACKOFF_BASE))
                        ;;
                esac
        
                ((RETRY_COUNT++))
            done
        
            if [ "$SUCCESS" = false ] && [ "$HTTP_CODE" != "404" ]; then
                echo -e "${RED}❌ API call failed after $MAX_RETRIES attempts: $URL${NC}" | tee -a error-log.txt
            fi
        }
        
        # --- Step 1: Paginated Fetch for All Linode IDs in the region with X-Filter ---
        echo -e "${BLUE}🌐 Fetching Linode IDs in region $REGION with Pagination...${NC}"
        while [ "$CURRENT_PAGE" -le "$TOTAL_PAGES" ]; do
            echo -e "${BLUE}   ➡️  Fetching page $CURRENT_PAGE of $TOTAL_PAGES${NC}"
            
            URL="https://api.linode.com/v4/linode/instances?page=$CURRENT_PAGE&page_size=$PAGE_SIZE"
            TEMP_RESPONSE=$(mktemp)
            
            # Fetch paginated data with retry logic
            retry_curl "$URL" "$TEMP_RESPONSE"
            
            # Fetch Linode IDs and append to file
            cat "$TEMP_RESPONSE" | jq -r '.data[] | .id' >> linodes.txt
            
            # Get pagination info
            TOTAL_PAGES=$(cat "$TEMP_RESPONSE" | jq -r '.pages')
            CURRENT_PAGE=$((CURRENT_PAGE + 1))
            rm -f "$TEMP_RESPONSE"
        done
        
        # --- Step 2: Count the number of Linode IDs and adjust MAX_JOBS ---
        TOTAL_LINODES=$(wc -l < linodes.txt)
        if [ "$TOTAL_LINODES" -lt "$INITIAL_JOBS" ]; then
            MAX_JOBS="$TOTAL_LINODES"
        else
            # --- Adjust parallel jobs based on latency ---
            AVG_LATENCY=$(awk '{sum+=$3} END {print int(sum/NR)}' latency-log.txt)
            
            if [ "$AVG_LATENCY" -lt 200 ]; then
                MAX_JOBS=20
            elif [ "$AVG_LATENCY" -lt 500 ]; then
                MAX_JOBS=10
            else
                MAX_JOBS=5
            fi
        fi
        
        echo -e "${GREEN}🔎 Found $TOTAL_LINODES Linode IDs. Adjusting parallel jobs to $MAX_JOBS (Avg Latency: $AVG_LATENCY ms)${NC}"
        
        # --- Step 3: Function to fetch VLAN IPs for a single Linode ---
        fetch_vlan_ips() {
            local LID=$1
            local TEMP_FILE=$(mktemp)
            local TEMP_RESPONSE=$(mktemp)
            echo -e "${GREEN}🔎 Checking Linode ID: $LID${NC}"
        
            # Fetch configurations for the Linode with retry logic and X-Filter for interfaces
            URL="https://api.linode.com/v4/linode/instances/$LID/configs"
            retry_curl "$URL" "$TEMP_RESPONSE"
        
            if [ $? -ne 0 ]; then
                echo -e "${RED}❌ [ERROR] Failed to fetch configs for Linode ID $LID${NC}" | tee -a error-log.txt
                return 1
            fi
        
            # Extract VLAN IPs directly (No additional curl calls)
            VLAN_IPS=$(cat "$TEMP_RESPONSE" | jq -r ".data[].interfaces[] | select(.purpose == \"vlan\") | .ipam_address")
        
            # Write to the temp file and success log
            if [ -n "$VLAN_IPS" ]; then
                echo "$VLAN_IPS" >> "$TEMP_FILE"
                echo -e "${GREEN}✅ [SUCCESS] VLAN IPs found for Linode ID $LID - $VLAN_IPS${NC}" | tee -a success-log.txt
            else
                echo -e "${YELLOW}⚠️ [INFO] No VLAN IPs found for Linode ID $LID${NC}" | tee -a success-log.txt
            fi
        
            # Append temp file to final output (atomic operation)
            if [ -s "$TEMP_FILE" ]; then
                cat "$TEMP_FILE" >> "$OUTPUT_FILE"
            fi
        
            rm -f "$TEMP_FILE" "$TEMP_RESPONSE"
        }
        
        # === Calculate IP addresses without ipcalc ===
        NETWORK_PREFIX=$(echo $SUBNET | cut -d'/' -f2)
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo $SUBNET | cut -d'/' -f1)"
        
        # Extract the IP segments correctly
        IFS=. read -r i1 i2 i3 i4 <<< "$(echo "$SUBNET" | cut -d'/' -f1)"
        
        # Sanity check
        if [ -z "$i1" ] || [ -z "$i2" ] || [ -z "$i3" ]; then
            echo -e "${RED}[ERROR] Subnet parsing failed. Please check the subnet format.${NC}"
            exit 1
        fi
        
        # Network IP (x.x.x.0)
        NETWORK_IP="${i1}.${i2}.${i3}.0/$NETWORK_PREFIX"
        
        # First usable IP (x.x.x.1)
        FIRST_IP="${i1}.${i2}.${i3}.1/$NETWORK_PREFIX"
        
        # Broadcast IP (x.x.x.255)
        BROADCAST_IP="${i1}.${i2}.${i3}.255/$NETWORK_PREFIX"
        
        # Reserved IPs Array
        RESERVED_IPS=("$NETWORK_IP" "$FIRST_IP" "$BROADCAST_IP")
        
        log "Reserved IPs for subnet $SUBNET: ${RESERVED_IPS[*]}"
        
        # Adding reserved IPs to $IP_FILE_PATH files
        log "Adding reserved IPs to the allocation list for reserving it..."
        for ip in "${RESERVED_IPS[@]}"; do
            if ! grep -q "^$ip$" "$IP_FILE_PATH"; then
                echo "$ip" >> "$IP_FILE_PATH"
                log "Reserved IP added to list: $ip"
            fi
        done
        
        # --- Export function and variables for parallel ---
        export -f fetch_vlan_ips retry_curl
        export LINODE_TOKEN OUTPUT_FILE MAX_RETRIES
        
        # --- Step 4: Parallel Processing of Linode IDs ---
        echo -e "${BLUE}🌐 Fetching VLAN IPs from configurations in parallel...${NC}"
        cat linodes.txt | parallel -j "$MAX_JOBS" fetch_vlan_ips {}
        
        # --- Cleanup ---
        rm -f linodes.txt
        
        # === Remove duplicates ===
        sort -u "$OUTPUT_FILE" -o "$OUTPUT_FILE"
        
        log "✅ VLAN IP file created at $OUTPUT_FILE"
        
        # === Write to etcd using etcdctl txn ===
        log "💾 Syncing IPs to etcd..." 
        log "✅ ETCD_ENDPOINTS is $ETCD_ENDPOINTS"
        
        if [ -z "$ETCD_ENDPOINTS" ]; then
            log "[ERROR] ETCD_ENDPOINTS not set."
            exit 1
        fi
        
        export ETCDCTL_API=3     
        
        while IFS= read -r ip; do
            key="/vlan/ip/$ip"
            output=$(etcdctl --endpoints="$ETCD_ENDPOINTS" put --prev-kv "$key" "true" 2>&1)
            if [[ "$output" == *"prev_kv"* ]]; then
                log "🔁 IP $ip already exists in etcd, skipping."
            else
                log "✅ IP $ip synced to etcd."
            fi
        done < "$OUTPUT_FILE"
        
        log "🎉 Initialization and etcd sync complete."

        echo -e "${GREEN}✅ VLAN IP Initialization Complete. IPs saved to etcd database."
        
        # --- Final Output ---
        cat "$OUTPUT_FILE"
        
        log "✅ IP List Initialization Complete. Saved to $IP_FILE_PATH"
  06-rest-api.py: |
        # Import necessary libraries for web server, concurrency, networking, and file handling
        from flask import Flask, jsonify, request
        from flask_cors import CORS
        import os
        import ipaddress
        import json
        import sys
        import time
        from filelock import FileLock
        import requests
        from concurrent.futures import ThreadPoolExecutor
        from datetime import datetime, timedelta
        import asyncio
        import aiohttp
        import psutil
        import signal
        import configparser
        import etcd3
        import random
        
        # Initialize Flask application instance
        app = Flask(__name__)
        # Enable Cross-Origin Resource Sharing (CORS) for this Flask app
        CORS(app)
        
        # Define the log file path for logging allocation and healthcheck events
        LOG_FILE = "/tmp/allocate-ip.log"
        
        # Maximum number of log lines to retain in the log file
        MAX_LOG_LINES = 1000
        
        # Maximum backoff time in seconds for retry loops (e.g., API retries)
        MAX_BACKOFF = 60
        
        # Cache dictionary to store VLAN IPs with a TTL for performance
        VLAN_IP_CACHE = {
            "ips": None,
            "timestamp": None,
            "ttl_seconds": int(os.getenv("CACHE_TTL_SECONDS", 60))
        }
        
        # Cache to validate region metadata to reduce repetitive API calls
        REGION_CACHE = {"valid": False, "timestamp": None, "ttl_seconds": 3600}
        
        
        # Signal handler to gracefully shutdown the app when terminated
        def graceful_exit(signalnum, frame):
            log(f"[INFO] Received signal {signalnum}. Shutting down gracefully...")
            sys.exit(0)
        
        
        # Register signal handlers for SIGTERM and SIGINT (Ctrl+C)
        signal.signal(signal.SIGTERM, graceful_exit)
        
        # Register signal handlers for SIGTERM and SIGINT (Ctrl+C)
        signal.signal(signal.SIGINT, graceful_exit)
        
        
        
        def validate_environment():
            REGION = os.getenv("REGION")
            if not REGION:
                log("[ERROR] REGION environment variable not set.")
                sys.exit(1)
            if not os.getenv("ETCD_ENDPOINTS"):
                log("[ERROR] ETCD_ENDPOINTS environment variable not set.")
                sys.exit(1)
        
            log("[INFO] Environment validation passed.")
        
        def log(message):
            timestamped_message = f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {message}"
            print(timestamped_message)
            sys.stdout.flush()
        
            try:
                with FileLock(LOG_FILE + ".lock"):
                    lines = []
        
                    # Read existing log if available
                    if os.path.exists(LOG_FILE):
                        with open(LOG_FILE, "r") as f:
                            lines = f.read().splitlines()
        
                    # Append new log entry and trim if necessary
                    lines.append(timestamped_message)
                    lines = lines[-MAX_LOG_LINES:]
        
                    # Write back to log file
                    with open(LOG_FILE, "w") as f:
                        f.write("\n".join(lines) + "\n")
            except Exception as e:
                print(f"[ERROR] Failed to write to log file: {str(e)}")
        
        
        def api_request_with_retry(url, headers, retries=3, backoff=2, jitter=True):
            """
            Make an HTTP GET request with retry, exponential backoff, and optional jitter.
            """
            for attempt in range(1, retries + 1):
                try:
                    response = requests.get(url, headers=headers, timeout=5)
        
                    if response.status_code == 200:
                        try:
                            return response.json()
                        except ValueError:
                            log(f"[ERROR] Invalid JSON response on attempt {attempt}: {response.text}")
                            return None
        
                    elif response.status_code == 429:
                        wait_time = int(response.headers.get("Retry-After", 5))
                        log(f"[WARN] Rate limited (429). Retrying after {wait_time}s (attempt {attempt}/{retries})")
                        time.sleep(wait_time)
        
                    elif response.status_code >= 500:
                        log(f"[WARN] Server error {response.status_code} on attempt {attempt}. Retrying...")
                        _sleep_with_backoff(backoff, attempt, jitter)
        
                    else:
                        log(f"[WARN] API error {response.status_code} on attempt {attempt}. Retrying...")
                        _sleep_with_backoff(backoff, attempt, jitter)
        
                except (requests.ConnectionError, requests.Timeout) as e:
                    log(f"[ERROR] Network error on attempt {attempt}: {str(e)}. Retrying...")
                    _sleep_with_backoff(backoff, attempt, jitter)
        
                except requests.RequestException as e:
                    log(f"[ERROR] Unexpected error on attempt {attempt}: {str(e)}. Retrying...")
                    _sleep_with_backoff(backoff, attempt, jitter)
        
            log(f"[ERROR] API call failed after {retries} attempts.")
            return None
        
        
        def _sleep_with_backoff(base_backoff, attempt, jitter=True):
            wait_time = min(base_backoff * (2 ** (attempt - 1)), MAX_BACKOFF)
            if jitter:
                wait_time += random.uniform(0.1, 0.5)
            log(f"[DEBUG] Waiting {wait_time:.2f}s before retrying...")
            time.sleep(wait_time)
        
        
        def fetch_linode_token(config_file='/root/.linode-cli/linode-cli'):
            """
            Read the Linode CLI config file and extract the token for the default user.
        
            Args:
                config_file (str): Path to the Linode CLI configuration file
        
            Returns:
                str: The token value, or None if not found
            """
            if not os.path.exists(config_file):
                log(f"[ERROR] Configuration file {config_file} not found")
                return None
        
            config = configparser.ConfigParser()
        
            try:
                config.read(config_file)
        
                if 'DEFAULT' not in config or 'default-user' not in config['DEFAULT']:
                    log(f"[ERROR] No 'default-user' found in {config_file}")
                    return None
        
                default_user = config['DEFAULT']['default-user']
        
                if default_user not in config:
                    log(f"[ERROR] User profile '{default_user}' not found in {config_file}")
                    return None
        
                token = config[default_user].get('token')
                if not token:
                    log(f"[ERROR] No token found for user '{default_user}' in {config_file}")
                    return None
        
                return token
        
            except Exception as e:
                log(f"[ERROR] Exception while reading configuration file: {str(e)}")
                return None
        
        def fetch_assigned_ips():
            if (
                    VLAN_IP_CACHE["ips"] is not None
                    and VLAN_IP_CACHE["timestamp"] is not None
                    and (datetime.now() - VLAN_IP_CACHE["timestamp"]).total_seconds() < VLAN_IP_CACHE["ttl_seconds"]
            ):
                log("[INFO] Using cached VLAN IPs")
                return VLAN_IP_CACHE["ips"]
        
            LINODE_TOKEN = fetch_linode_token()
            REGION = os.getenv("REGION")
        
            if not REGION:
                log("[ERROR] REGION environment variable not set")
                raise EnvironmentError("REGION environment variable not set")
        
            if not LINODE_TOKEN:
                log("[ERROR] Missing Linode Token")
                return None
        
            headers = {"Authorization": f"Bearer {LINODE_TOKEN}"}
            log(f"[DEBUG] Fetching VLAN IPs for region: {REGION}")
        
            url = "https://api.linode.com/v4/linode/instances"
            instances = api_request_with_retry(url, headers={"Authorization": f"Bearer {LINODE_TOKEN}",
                                                             "X-Filter": f'{{"region": "{REGION}"}}'})
        
            if not instances:
                log("[ERROR] Failed to fetch Linode instances")
                return None
        
            linode_ids = [str(l["id"]) for l in instances.get("data", [])]
            log(f"[DEBUG] Linode IDs fetched: {linode_ids}")
        
            vlan_ips = []
        
            def fetch_configs(linode_id):
                try:
                    log(f"[DEBUG] Fetching VLAN IPs for Linode ID: {linode_id}")
                    config_url = f"https://api.linode.com/v4/linode/instances/{linode_id}/configs"
                    configs = api_request_with_retry(config_url, headers)
                    if not configs:
                        log(f"[ERROR] Failed to fetch configurations for Linode ID {linode_id}")
                        return []
                    linode_vlan_ips = []
                    for config in configs.get("data", []):
                        for iface in config.get("interfaces", []):
                            if iface.get("purpose") == "vlan":
                                ip_address = iface.get("ipam_address")
                                if ip_address:
                                    linode_vlan_ips.append(ip_address)
                                    log(f"[DEBUG] Found VLAN IP: {ip_address}")
                    return linode_vlan_ips
                except Exception as e:
                    log(f"[ERROR] Exception in fetch_configs for Linode ID {linode_id}: {str(e)}")
                    return []
        
            max_workers = int(os.getenv("MAX_WORKERS", 20))
            max_workers = min(max_workers, max(1, len(linode_ids)))
            if max_workers == 1 and len(linode_ids) > 1:
                log(f"[WARN] Only 1 worker thread available with {len(linode_ids)} Linode instances. Possible API rate limiting.")
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                results = executor.map(fetch_configs, linode_ids)
                for result in results:
                    vlan_ips.extend(result)
        
            log(f"[DEBUG] All VLAN IPs in region {REGION}: {vlan_ips}")
        
            VLAN_IP_CACHE["ips"] = vlan_ips
            VLAN_IP_CACHE["timestamp"] = datetime.now()
        
            return vlan_ips
        
        def system_health_check():
            load_avg = os.getloadavg()
            mem = psutil.virtual_memory()
            mem_info = f"Total: {mem.total / (1024 ** 2):.2f} MB, Used: {mem.used / (1024 ** 2):.2f} MB, Free: {mem.free / (1024 ** 2):.2f} MB"
            log(f"[INFO] System Load Average: {load_avg}")
            log(f"[INFO] Memory Information: {mem_info}")
            if load_avg[0] > os.cpu_count() * 2:
                log("[WARN] High system load detected")
                return False
            if mem.percent > 90:
                log("[WARN] High memory usage detected")
                return False
            return True
        
        def get_etcd_connection():
            endpoints = os.getenv("ETCD_ENDPOINTS", "")
            if not endpoints:
                raise EnvironmentError("ETCD_ENDPOINTS not set in environment")
        
            # Try each endpoint until successful
            for ep in endpoints.split(","):
                ep = ep.replace("http://", "").replace("https://", "").rstrip("/")  # Normalize scheme and slashes
        
                parts = ep.split(":")
                if len(parts) != 2:
                    log(f"[ERROR] Invalid ETCD endpoint format: {ep}. Expected format: host:port")
                    continue
        
                host = parts[0]
                try:
                    port = int(parts[1])
                except ValueError:
                    log(f"[ERROR] Port is not a valid integer in endpoint: {ep}")
                    continue
        
                try:
                    client = etcd3.client(host=host, port=port)
                    client.status()  # Health check
                    log(f"[INFO] Connected to etcd: {host}:{port}")
                    return client
                except Exception as e:
                    log(f"[WARN] Failed to connect to etcd endpoint {host}:{port}: {str(e)}")
                    continue
        
            raise ConnectionError("Unable to connect to any etcd endpoint")
        
        
        # =======================
        # 🟢 Allocate IP Endpoint Sandip
        # =======================
        @app.route('/allocate', methods=['POST'])
        def allocate_ip():
            try:
                subnet = request.json.get('subnet')
                if not subnet:
                    log("[ERROR] Subnet not provided")
                    return jsonify({"error": "Subnet not provided"}), 400
        
                REGION = os.getenv("REGION")
                if not REGION:
                    log("[ERROR] Region not provided")
                    return jsonify({"error": "Region not provided"}), 400
        
                log(f"[DEBUG] Subnet: {subnet}, Region: {REGION}")
        
                try:
                    ip_net = ipaddress.ip_network(subnet, strict=False)
                    cidr_suffix = f"/{ip_net.prefixlen}"
                except ValueError:
                    log("[ERROR] Invalid subnet format")
                    return jsonify({"error": "Invalid subnet format"}), 400
        
                # Connect to etcd
                etcd = get_etcd_connection()
                if not etcd:
                    return jsonify({"error": "Unable to connect to etcd"}), 500
        
                # Fetch all IPs already used from etcd
                etcd_used_ips = set()
                for value, meta in etcd.get_prefix("/vlan/ip/"):
                    if meta.key:
                        etcd_used_ips.add(meta.key.decode("utf-8").replace("/vlan/ip/", ""))
        
                log(f"[DEBUG] IPs found in etcd: {etcd_used_ips}")
        
                # ✅ Fetch all Linode-assigned VLAN IPs (even if not in etcd)
                linode_assigned_ips = set(fetch_assigned_ips())
        
                # ✅ Merge both to get full list of used IPs
                used_ips = etcd_used_ips.union(linode_assigned_ips)
        
                # Sync missing IPs into etcd
                missing_in_etcd = linode_assigned_ips - etcd_used_ips
                for ip in missing_in_etcd:
                    try:
                        etcd.put(f"/vlan/ip/{ip}", "true")
                        log(f"[SYNC] Added missing Linode-assigned IP to etcd: {ip}")
                    except Exception as e:
                        log(f"[ERROR] Failed to sync IP {ip} to etcd: {str(e)}")
        
                used_ips = etcd_used_ips.union(linode_assigned_ips)
        
                # Determine reserved IPs
                hosts = list(ip_net.hosts())
                if len(hosts) >= 3:
                    reserved_ips = {
                        str(hosts[0]),
                        str(hosts[1]),
                        str(hosts[-1])
                    }
                else:
                    reserved_ips = set()
        
                skipped_reserved = 0
                attempted_ips = 0
        
                # Begin IP scan
                for ip in hosts:
                    candidate_ip = f"{ip}{cidr_suffix}"
                    attempted_ips += 1
        
                    if candidate_ip in reserved_ips:
                        log(f"[INFO] Skipping Reserved IP: {candidate_ip}")
                        skipped_reserved += 1
                        continue
        
                    if candidate_ip in used_ips:
                        log(f"[INFO] Skipping Already Allocated IP: {candidate_ip}")
                        continue
        
                    try:
                        key = f"/vlan/ip/{candidate_ip}"
                        txn_success, _ = etcd.transaction(
                            compare=[
                                etcd.transactions.version(key) == 0  # Key must not exist
                            ],
                            success=[
                                etcd.transactions.put(key, "true")
                            ],
                            failure=[]
                        )
        
                        if txn_success:
                            log(f"[SUCCESS] Allocated IP: {candidate_ip}")
                            return jsonify({"allocated_ip": candidate_ip}), 200
                        else:
                            log(f"[INFO] Race condition — IP was just taken: {candidate_ip}")
                            continue
                    except Exception as e:
                        log(f"[ERROR] etcd put failed for {candidate_ip}: {str(e)}")
                        return jsonify({"error": f"Failed to allocate IP: {str(e)}"}), 500
        
                error_msg = (
                    f"No IPs available in subnet {subnet}. "
                    f"Attempted {attempted_ips} IPs, "
                    f"{skipped_reserved} were reserved, "
                    f"{len(used_ips)} already allocated."
                )
                log(f"[ERROR] {error_msg}")
                return jsonify({"error": error_msg}), 400
        
            except Exception as e:
                log(f"[ERROR] Unexpected error in /allocate endpoint: {str(e)}")
                return jsonify({"error": f"Unexpected error: {str(e)}"}), 500
        
        
        # =======================
        # 🔴 Release IP Endpoint
        # =======================
        @app.route('/release', methods=['POST'])
        def release_ip():
            try:
                ip_address = request.json.get('ip_address')
                if not ip_address:
                    return jsonify({"error": "IP address not provided"}), 400
        
                ip_address = ip_address.strip()
                REGION = os.getenv("REGION")
                SUBNET = os.getenv("SUBNET")
                if not REGION or not SUBNET:
                    return jsonify({"error": "Missing REGION or SUBNET env variable"}), 500
        
                try:
                    ip_net = ipaddress.ip_network(SUBNET, strict=False)
                    cidr_suffix = f"/{ip_net.prefixlen}"
                    hosts = list(ip_net.hosts())
        
                    reserved_ips = set()
                    if len(hosts) >= 3:
                        reserved_ips = {
                            str(hosts[0]),
                            str(hosts[1]),
                            str(hosts[-1])
                        }
        
                    if ip_address in reserved_ips:
                        log(f"[WARN] Attempted to release reserved IP: {ip_address}")
                        return jsonify({"error": f"IP address {ip_address} is reserved and cannot be released."}), 403
        
                    etcd = get_etcd_connection()
                    if not etcd:
                        return jsonify({"error": "Failed to connect to etcd"}), 500
        
                    key = f"/vlan/ip/{ip_address}"
                    deleted = etcd.delete(key)
        
                    if deleted:
                        log(f"[INFO] Released IP from etcd: {ip_address}")
                        return jsonify({"status": "IP released", "ip": ip_address}), 200
                    else:
                        log(f"[WARN] IP {ip_address} not found in etcd")
                        return jsonify({"error": f"IP address {ip_address} not found in etcd"}), 404
        
                except Exception as e:
                    log(f"[ERROR] Release failed: {str(e)}")
                    return jsonify({"error": f"Release failed: {str(e)}"}), 500
        
            except Exception as e:
                log(f"[ERROR] Unexpected error in /release endpoint: {str(e)}")
                return jsonify({"error": f"Unexpected error: {str(e)}"}), 500
        
        # =======================
        # 🔵 Health Check Endpoint
        # =======================
        @app.route('/health', methods=['GET'])
        def health_check():
            try:
                linode_token = fetch_linode_token()
                if not linode_token:
                    log("[ERROR] Health check: Failed to validate Linode CLI configuration")
                    return jsonify({"status": "unhealthy", "error": "Invalid Linode CLI configuration"}), 500
        
                headers = {"Authorization": f"Bearer {linode_token}"}
                REGION = os.getenv("REGION")
                if not REGION:
                    log("[ERROR] Health check: REGION environment variable not set")
                    return jsonify({"status": "unhealthy", "error": "REGION environment variable not set"}), 500
        
                start_time = time.time()
                response = requests.get("https://api.linode.com/v4/account", headers=headers, timeout=5)
                end_time = time.time()
                latency_ms = (end_time - start_time) * 1000
                if latency_ms > 200:
                    log(f"[WARN] Linode API latency is high: {latency_ms:.2f} ms")
                if response.status_code == 401:
                    log("[ERROR] Health check: Unauthorized access. Token might be invalid")
                    return jsonify({"status": "unhealthy", "error": "Unauthorized access"}), 500
                if response.status_code != 200:
                    log(f"[ERROR] Health check: Failed to connect to Linode API, status {response.status_code}")
                    return jsonify({"status": "unhealthy", "error": "Failed to connect to Linode API"}), 500
        
                response = requests.get("https://api.linode.com/v4/networking/ips", headers=headers, timeout=5)
                if response.status_code != 200:
                    log(f"[ERROR] Health check: Failed to access networking API, status {response.status_code}")
                    return jsonify({"status": "unhealthy", "error": "Failed to access networking API"}), 500
        
                if (
                        REGION_CACHE["timestamp"] is None
                        or (datetime.now() - REGION_CACHE["timestamp"]).total_seconds() > REGION_CACHE["ttl_seconds"]
                ):
                    response = requests.get(f"https://api.linode.com/v4/regions/{REGION}", headers=headers, timeout=5)
                    if response.status_code != 200:
                        log(f"[ERROR] Health check: Invalid or unavailable region {REGION}, status {response.status_code}")
                        return jsonify({"status": "unhealthy", "error": f"Invalid or unavailable region {REGION}"}), 500
                    REGION_CACHE["valid"] = True
                    REGION_CACHE["timestamp"] = datetime.now()
                elif not REGION_CACHE["valid"]:
                    log(f"[ERROR] Health check: Cached result indicates invalid region {REGION}")
                    return jsonify({"status": "unhealthy", "error": f"Invalid or unavailable region {REGION}"}), 500
                try:
                    etcd = get_etcd_connection()
                    etcd.status()
                except Exception as e:
                    log(f"[ERROR] Health check: Failed to connect to etcd: {str(e)}")
                    return jsonify({"status": "unhealthy", "error": f"etcd connection failed: {str(e)}"}), 500
        
                if not system_health_check():
                    log("[ERROR] Health check: System health checks failed")
                    return jsonify({"status": "unhealthy", "error": "System health checks failed"}), 500
        
                log("[INFO] Health check: All checks passed")
                return jsonify({"status": "healthy", "latency_ms": latency_ms}), 200
        
            except requests.RequestException as e:
                log(f"[ERROR] Health check: Network connectivity error: {str(e)}")
                return jsonify({"status": "unhealthy", "error": f"Network connectivity error: {str(e)}"}), 500
            except Exception as e:
                log(f"[ERROR] Health check: Unexpected error: {str(e)}")
                return jsonify({"status": "unhealthy", "error": f"Unexpected error: {str(e)}"}), 500
        
        # =======================
        # 🚀 Start Flask Application
        # =======================
        if __name__ == '__main__':
            validate_environment()
            app.run(host='0.0.0.0', port=8080, debug=True)